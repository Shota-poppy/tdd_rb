:toc: left
:toclevels: 5
:sectnums:

= テスト駆動開発から始めるRuby入門

これはとあるプログラマがどのような思考を経てテスト駆動開発でアプリケーションを構築していったかを解説した内容である。隣りに座って話を聞きながらコードを追いかけているイメージで読み進めてみてださい。

== エピソード1
=== TODOリストから始めるテスト駆動開発
==== TODOリスト

アプリケーションを作成するにあたってまず何をすればよいだろうか？私は、まず仕様の確認をして *TODOリスト* を作るところから始めます。

[quote, '_テスト駆動開発_ <<tdd>>']
____
TODOリスト

何をテストすべきだろうか----着手する前に、必要になりそうなテストをリストに書き出しておこう。
____

仕様

  1 から 100 までの数をプリントするプログラムを書け。
  ただし 3 の倍数のときは数の代わりに｢Fizz｣と、5 の倍数のときは｢Buzz｣とプリントし、
  3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントすること。

仕様の内容をそのままプログラムに落とし込むには少しサイズが大きいようですね。なので最初の作業は仕様をTODOリストに分解する作業から着手することにしましょう。仕様をどのようにTODOに分解していくかは https://channel9.msdn.com/Events/de-code/2017/DO03?ocid=player[50 分でわかるテスト駆動開発^] の26分あたりを参考にしてください。


TODOリスト

* 数を文字列にして返す
* 3 の倍数のときは数の代わりに｢Fizz｣と返す
* 5 の倍数のときは｢Buzz｣と返す
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

まず `数を文字列にして返す` 作業に取り掛かりたいのですがまだプログラミング対象としてはサイズが大きいようですね。もう少し具体的に分割しましょう。

* 数を文字列にして返す
** 1を渡したら文字列"1"を返す

これならプログラムの対象として実装できそうですね。

=== テストファーストから始めるテスト駆動開発
==== テストファースト

最初にプログラムする対象を決めたので早速プロダクトコードを実装・・・ではなく *テストファースト* で作業を進めていきましょう。まずはプログラムを実行するための準備作業を進める必要がありますね。

[quote, '_テスト駆動開発_ <<tdd>>']
____
テストファースト

いつテストを書くべきだろうか----それはテスト対象のコードを書く前だ。
____

では、どうやってテストすればいいでしょうか？テスティングフレームワークを使って自動テストを書きましょう。

[quote, '_テスト駆動開発_ <<tdd>>']
____
テスト（名詞）
どうやってソフトウェアをテストすればよいだろか----自動テストを書こう。
____

今回Rubyのテスティングフレームワークには http://docs.seattlerb.org/minitest/[Minitest^] を利用します。Minitestの詳しい使い方に関しては _Minitestの基本_ <<pruby>>を参照してください。
では、まず以下の内容のテキストファイルを作成して `main.rb` で保存します。

[source, ruby]
----
require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'

class HelloTest < Minitest::Test
  def test_greeting
    assert_equal 'hello world', greeting
  end
end

def greeting
  'hello world'
end
----

テストを実行します。

[source, bash]
----
$ ruby main.rb
Started with run options --seed 9701

  1/1: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00090s
1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
----

テストは成功しましたね。では続いてテストを失敗させてみましょう。`hello world` を `hello world!!!` に書き換えてテストを実行してみるとどうなるでしょうか。

[source, ruby]
----
...
class HelloTest < Minitest::Test
  def test_greeting
    assert_equal 'hello world!!!', greeting
  end
end
...
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 18217

 FAIL["test_greeting", #<Minitest::Reporters::Suite:0x00007f98a59194f8 @name="HelloTest">, 0.0007280000027094502]
 test_greeting#HelloTest (0.00s)
        Expected: "hello world!!!"
          Actual: "hello world"
        main.rb:11:in `test_greeting'

  1/1: [======================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00101s
1 tests, 1 assertions, 1 failures, 0 errors, 0 skips
----

オッケー、テスティングフレームワークが正常に読み込まれて動作することが確認できました。続いてバージョン管理システムのセットアップをしておきましょう。バージョン管理システム何それ？だって！？君はセーブしないでロールプレイングゲームをクリアできるのか？できないならまず https://backlog.com/ja/git-tutorial/intro/01/[ここ^] でGitを使ったバージョン管理の基本を学んでおきましょう。

[source, bash]
----
$ git init
$ git add .
$ git commit -m 'セットアップ'
----

これで https://t-wada.hatenablog.jp/entry/clean-code-that-works[ソフトウェア開発の三種の神器^]のうち *バージョン管理* と *テスティング* の準備が整いましたので *TODOリスト* の最初の作業に取り掛かかるとしましょう。

=== アサートファーストから始めるテスト駆動開発

==== 仮実装

TODOリスト

* 数を文字列にして返す
** *1を渡したら文字列"1"を返す*
* 3 の倍数のときは数の代わりに｢Fizz｣と返す
* 5 の倍数のときは｢Buzz｣と返す
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

*1を渡したら文字列"1"を返す* プログラムを `main.rb` に書きましょう。最初に何を書くのかって？ アサーションを最初に書きましょう。

[quote, '_テスト駆動開発_ <<tdd>>']
____
アサートファースト

いつアサーションを書くべきだろうか----最初に書こう

* システム構築はどこから始めるべきだろうか。システム構築が終わったらこうなる、というストーリーを語るところからだ。
* 機能はどこから書き始めるべきだろうか。コードが書き終わったらこのように動く、というテストを書くところからだ。
* ではテストはどこから書き始めるべきだろうか。それはテストの終わりにパスすべきアサーションを書くところからだ。
____

検証コードを書いて。

[source, ruby]
----
...
class FizzBuzzTest < Minitest::Test
  def test_1を渡したら文字列1を返す
    # 前準備
    # 実行
    # 検証
    assert_equal '1', FizzBuzz.generate(1)
  end
end
----

テストを実行します。

[source, bash]
----
$ ruby main.rb
Started with run options --seed 678

ERROR["test_1を渡したら文字列1を返す", #<Minitest::Reporters::Suite:0x00007f956d8b6870 @name="FizzBuzzTest">, 0.0006979999998293351]
 test_1を渡したら文字列1を返す#FizzBuzzTest (0.00s)
NameError:         NameError: uninitialized constant FizzBuzzTest::FizzBuzz
        Did you mean?  FizzBuzzTest
            main.rb:10:in `test_1を渡したら文字列1を返す'

  1/1: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00201s
1 tests, 0 assertions, 0 failures, 1 errors, 0 skips
----

`NameError:         NameError: uninitialized constant FizzBuzzTest::FizzBuzz` ...FizzBuzzが定義されていない。そうですねまだ作ってないのだから当然ですよね。では `FizzBuzz.generate` メソッドを作りましょう。どんな振る舞いを書けばいいのでしょうか？とりあえず最初のテストを通すため *仮実装* から始めるとしましょう。

[quote, '_テスト駆動開発_ <<tdd>>']
____
仮実装を経て本実装へ

失敗するテストを書いてから、最初に行う実装はどのようなものだろうか----ベタ書きの値を返そう。
____

[source, ruby]
----
...
class FizzBuzzTest < Minitest::Test
  def test_1を渡したら文字列1を返す
    # 前準備
    # 実行
    # 検証
    assert_equal '1', FizzBuzz.generate(1)
  end
end

class FizzBuzz
  def self.generate(n)
    '1'
  end
end
----

テストが通ることを確認します。

[source, bash]
----
$ ruby main.rb
Started with run options --seed 60122

  1/1: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00094s
1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
----

オッケー、これでTODOリストを片付けることができました。え？こんなベタ書きのプログラムでいいの？他に考えないといけないことたくさんあるんじゃない？ばかじゃないの？と思われるかもしませんが、この細かいステップに今しばらくお付き合いいただきたい。

TODOリスト

* 数を文字列にして返す
** [line-through]*1を渡したら文字列"1"を返す*
* 3 の倍数のときは数の代わりに｢Fizz｣と返す
* 5 の倍数のときは｢Buzz｣と返す
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

==== 三角測量

1を渡したら文字列1を返すようにできました。では、2を渡したらどうなるでしょうか？

TODOリスト

* 数を文字列にして返す
** [line-through]_1を渡したら文字列"1"を返す_
** *2を渡したら文字列"2"を返す*
* 3 の倍数のときは数の代わりに｢Fizz｣と返す
* 5 の倍数のときは｢Buzz｣と返す
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

[source, ruby]
----
...
class FizzBuzzTest < Minitest::Test
  def test_1を渡したら文字列1を返す
    # 前準備
    # 実行
    # 検証
    assert_equal '1', FizzBuzz.generate(1)
  end

  def test_2を渡したら文字列2を返す
    # 前準備
    # 実行
    # 検証
    assert_equal '2', FizzBuzz.generate(2)
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 62350

 FAIL["test_2を渡したら文字列2を返す", #<Minitest::Reporters::Suite:0x00007fa4968938d8 @name="FizzBuzzTest">, 0.0009390000013809185]
 test_2を渡したら文字列2を返す#FizzBuzzTest (0.00s)
        Expected: "2"
          Actual: "1"
        main.rb:17:in `test_2を渡したら文字列2を返す'

  2/2: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00179s
2 tests, 2 assertions, 1 failures, 0 errors, 0 skips
----

テストが失敗しました。それは文字列1しか返さないプログラムなのだから当然ですよね。では1が渡されたら文字列1を返し、2を渡したら文字列2を返すようにプログラムを修正しましょう。

[source, ruby]
----
...
class FizzBuzz
  def self.generate(n)
    n.to_s
  end
end
----

テストを実行します。

[source, bash]
----
$ ruby main.rb
Started with run options --seed 42479

  2/2: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00098s
2 tests, 2 assertions, 0 failures, 0 errors, 0 skips
----

テストが無事通りました。このように２つ目のテストによって `FizzBuzz::generate` メソッドの一般化を実現することができました。このようなアプローチを *三角測量* と言います。

[quote, '_テスト駆動開発_<<tdd>>']
____
三角測量

テストから最も慎重に一般化を引き出すやり方はどのようなものだろうか----２つ以上の例があるときだけ、一般化を行うようにしよう。
____

TODOリスト

* [line-through]*数を文字列にして返す*
** [line-through]_1を渡したら文字列"1"を返す_
** [line-through]_2を渡したら文字列"2"を返す_
* 3 の倍数のときは数の代わりに｢Fizz｣と返す
* 5 の倍数のときは｢Buzz｣と返す
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

たかが *数を文字列にして返す* プログラムを書くのにこんなに細かいステップを踏んでいくの？思ったかもしれません。プログラムを書くということは細かいステップを踏んで行くことなのです。そして、細かいステップを踏み続けることが大切なことなのです。
[quote, '_テスト駆動開発_<<tdd>>']
____
TDDで大事なのは、細かいステップを踏むことではなく、細かいステップを踏み続けられるようになることだ。
____

ここで一段落ついたので、これまでの作業内容をバージョ管理システムにコミットしておきましょう。

[source, bash]
----
git commit -m 'test: 数を文字列にして返す'
----


=== リファクタリングから始めるテスト駆動開発
==== リファクタリング

ここでテスト駆動開発の流れを確認しておきましょう。

[quote, '_テスト駆動開発_<<tdd>>']
____
1. レッド：動作しない、おそらく最初のうちはコンパイルも通らないテストを１つ書く。
1. グリーン:そのテストを迅速に動作させる。このステップでは罪を犯してもよい。
1. リファクタリング:テストを通すために発生した重複をすべて除去する。

レッド・グリーン・リファクタリング。それがTDDのマントラだ。
____

コードはグリーンの状態ですが *リファクタリング* を実施していませんね。重複を除去しましょう。

テストコードを見てください。テストを実行するにあたって毎回前準備を実行する必要があります。こうした処理は往々にして同じ処理を実行するものなので *メソッドの抽出* を適用して重複を除去しましょう。

[source, ruby]
----
class FizzBuzzTest < Minitest::Test
  def test_1を渡したら文字列1を返す
    # 前準備
    # 実行
    # 検証
    assert_equal '1', FizzBuzz.generate(1)
  end

  def test_2を渡したら文字列2を返す
    # 前準備
    # 実行
    # 検証
    assert_equal '2', FizzBuzz.generate(2)
  end
end
----

テストフレームワークでは前処理にあたる部分を実行する機能がサポートされています。Minitestでは `setup` メソッドがそれに当たるので `FizzBuzz` オブジェクトを共有して共通利用できるようにしてみましょう。

[source, ruby]
----
class FizzBuzzTest < Minitest::Test
  def setup
    @fizzbuzz = FizzBuzz
  end

  def test_1を渡したら文字列1を返す
    assert_equal '1', @fizzbuzz.generate(1)
  end

  def test_2を渡したら文字列2を返す
    assert_equal '2', @fizzbuzz.generate(2)
  end
end
----

テストプログラムを変更してしまいましたが壊れていないでしょうか？確認するにはどうすればいいでしょう？
テストを実行して確認すればいいですよね。

[source, bash]
----
$ ruby main.rb
Started with run options --seed 33356

  2/2: [======================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00083s
2 tests, 2 assertions, 0 failures, 0 errors, 0 skips
----

オッケー、前回コミットした時と同じグリーンの状態のままですよね。区切りが良いのでここでコミットしておきましょう。

[source, bash]
----
git commit -m 'refactor: メソッドの抽出'
----


もう一つ気になるところがあります。

[source, ruby]
----
...
class FizzBuzz
  def self.generate(n)
    n.to_s
  end
end
----

引数の名前が `n` ですね。コンピュータにはわかるかもしれませんが人間が読むコードとして少し不親切です。特にRubyのような動的言語では型が明確に定義されないのでなおさらです。ここは *変数名の変更* を適用して人間にとって読みやすいコードにリファクタリングしましょう。

[source, ruby]
----
...
class FizzBuzz
  def self.generate(number)
    number.to_s
  end
end
----

続いて、変更で壊れていないかを確認します。

[source, bash]
----
$ ruby main.rb
Started with run options --seed 33356

  2/2: [======================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00083s
2 tests, 2 assertions, 0 failures, 0 errors, 0 skips
----


オッケー、この時点でテストコードとプロダクトコードを変更しましたがその変更はすでに作成した自動テストによって壊れていないことを簡単に確認することができました。え、こんな簡単な変更でプログラムが壊れるわけないじゃん、ドジっ子なの？ですって。残念ながら私は絶対ミスしない完璧な人間ではないし、どちらかといえば注意力の足りないプログラマなのでこんな間違いも普通にやらかします。

[source, ruby]
----
...
class FizzBuzz
  def self.generate(number)
    numbr.to_s
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 59453

ERROR["test_1を渡したら文字列1を返す", #<Minitest::Reporters::Suite:0x0000564f6b1dfc70 @name="FizzBuzzTest">, 0.001019135997921694]
 test_1を渡したら文字列1を返す#FizzBuzzTest (0.00s)
NameError:         NameError: undefined local variable or method `numbr' for FizzBuzz:Class
        Did you mean?  number
            main.rb:21:in `generate'
            main.rb:11:in `test_1を渡したら文字列1を返す'

ERROR["test_2を渡したら文字列2を返す", #<Minitest::Reporters::Suite:0x0000564f6b1985f0 @name="FizzBuzzTest">, 0.003952859999117209]
 test_2を渡したら文字列2を返す#FizzBuzzTest (0.00s)
NameError:         NameError: undefined local variable or method `numbr' for FizzBuzz:Class
        Did you mean?  number
            main.rb:21:in `generate'
            main.rb:15:in `test_2を渡したら文字列2を返す'

  2/2: [====================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00746s
2 tests, 0 assertions, 0 failures, 2 errors, 0 skips
----

最初にプロダクトコードを書いて一通りの機能を作ってから動作を確認する進め方だとこの手の間違いはいつどこで作り込んだのかわからなくなるため原因の調査に時間がかかり残念な経験をしたドジっ子プログラマは変更なんてするもんじゃないと思いコードを変更することに不安を持つようになるでしょう。でも、テスト駆動開発ならそんなドジっ子プログラマでも自動テストと小さなステップのおかげで上記のようなしょうもない間違いもすぐに見つけてすぐに対応することができるのでコードを変更する勇気を持つことができるのです。

[quote, '_テスト駆動開発_<<tdd>>']
____
テスト駆動開発は、プログラミング中の不安をコントロールする手法だ。
____

このグリーンの状態にいつでも戻れるようにコミットして次の *TODOリスト* の内容に取り掛かるとしましょう。

[source, bash]
----
git commit -m 'refactor: 変数名の変更'
----

==== 明白な実装

次は *3を渡したら文字列"Fizz"* を返すプログラムに取り組むとしましょう。

TODOリスト

* [line-through]_数を文字列にして返す_
** [line-through]_1を渡したら文字列"1"を返す_
** [line-through]_2を渡したら文字列"2"を返す_
* 3 の倍数のときは数の代わりに｢Fizz｣と返す
** *3を渡したら文字列"Fizz"を返す*
* 5 の倍数のときは｢Buzz｣と返す
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

まずは、*テストファースト* *アサートファースト* で小さなステップで進めていくんでしたよね。

[source, ruby]
----
...
  def test_3を渡したら文字列Fizzを返す
    assert_equal 'Fizz', @fizzbuzz.generate(3)
  end
...
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 7095

 FAIL["test_3を渡したら文字列Fizzを返す", #<Minitest::Reporters::Suite:0x00007fbadf865f50 @name="FizzBuzzTest">, 0.017029999995429534]
 test_3を渡したら文字列Fizzを返す#FizzBuzzTest (0.02s)
        --- expected
        +++ actual
        @@ -1 +1,3 @@
        -"Fizz"
        +# encoding: US-ASCII
        +#    valid: true
        +"3"
        main.rb:19:in `test_3を渡したら文字列Fizzを返す'

  3/3: [======================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.05129s
3 tests, 3 assertions, 1 failures, 0 errors, 0 skips
----

さて、失敗するテストを書いたので次はテストを通すためのプロダクトコードを書くわけですがどうしましょうか？　*仮実装*　でベタなコードを書きますか？実現したい振る舞いは `もし3を渡したらならば文字列Fizzを返す` です。英語なら `If number is 3, result is Fizz` といったところでしょうか。ここは *明白な実装* で片付けた方が早いでしょう。

[quote, '_テスト駆動開発_<<tdd>>']
____
明白な実装

シンプルな操作を実現するにはどうすればいいだろうか----そのまま実装しよう。

仮実装や三角測量は、細かく細かく刻んだ小さなステップだ。だが、ときには実装をどうすべきか既に見えていることが。
そのまま進もう。例えば先ほどのplusメソッドくらいシンプルなものを仮実装する必要が本当にあるだろうか。
普通は、その必要はない。頭に浮かんだ明白な実装をただ単にコードに落とすだけだ。もしもレッドバーが出て驚いたら、あらためてもう少し歩幅を小さくしよう。
____

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    number.to_s
  end
end
----

ここでは *if文* と *演算子* を使ってみましょう。なんかプログラムっぽくなってきましたね。

`%` は割り算の余りを求める演算子<<pruby>>です。

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number % 3 == 0
       result = 'Fizz'
    end
    result
  end
end
----

テストがグリーンになったのでコミットしておきます。

[source, bash]
----
$ ruby main.rb
$ git commit -m 'test: 3を渡したら文字列Buzzを返す'
----

TODOリスト

* [line-through]_数を文字列にして返す_
** [line-through]_1を渡したら文字列"1"を返す_
** [line-through]*2を渡したら文字列"2"を返す*
* [line-through]_3 の倍数のときは数の代わりに｢Fizz｣と返す_
** [line-through]_3を渡したら文字列"Fizz"を返す_
* 5 の倍数のときは｢Buzz｣と返す
** 5を渡したら文字列"Buzz"を返す
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number % 3 == 0
       result = 'Fizz'
    end
    result
  end
end
----

レッド・グリーンときたので次はリファクタリングですね。

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero? == 0
       result = 'Fizz'
    end
    result
  end
end
----

ここでは *アルゴリズムの置き換え* を適用してよりRubyらしい書き方にリファクタリングしてみました。

[source, bash]
----
$ ruby main.rb
$ git commit -m 'refactor: アルゴリズムの置き換え'
----

だんだんとリズムに乗ってきました。ここはギアを上げて *明白な実装* で引き続き *TODOリスト* の内容を片付けていきましょう。

TODOリスト

* [line-through]_数を文字列にして返す_
** [line-through]_1を渡したら文字列"1"を返す_
** [line-through]_2を渡したら文字列"2"を返す_
* [line-through]_3の倍数のときは数の代わりに｢Fizz｣と返す_
** [line-through]_3を渡したら文字列"Fizz"を返す_
* 5 の倍数のときは｢Buzz｣と返す
** *5を渡したら文字列"Buzz"を返す*
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

[source, ruby]
----
...
  def test_5を渡したら文字列Buzzを返す
    assert_equal 'Buzz', @fizzbuzz.generate(5)
  end
end
----

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero? == 0
       result = 'Fizz'
    end
    result
  end
end
----

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero?
      result = 'Fizz'
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end
    result
  end
end
----

[source, bash]
----
$ ruby main.rb
$ git commit -m 'test: 5を渡したら文字列Buzzを返す'
----

TODOリスト

* [line-through]_数を文字列にして返す_
** [line-through]_1を渡したら文字列"1"を返す_
** [line-through]_2を渡したら文字列"2"を返す_
* [line-through]_3の倍数のときは数の代わりに｢Fizz｣と返す_
** [line-through]_3を渡したら文字列"Fizz"を返す_
* 5 の倍数のときは｢Buzz｣と返す
** [line-through]*5を渡したら文字列"Buzz"を返す*
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

[source, ruby]
----
class FizzBuzzTest < Minitest::Test
  def setup
    @fizzbuzz = FizzBuzz
  end

  def test_1を渡したら文字列1を返す
    assert_equal '1', @fizzbuzz.generate(1)
  end

  def test_2を渡したら文字列2を返す
    assert_equal '2', @fizzbuzz.generate(2)
  end

  def test_3を渡したら文字列Fizzを返す
    assert_equal 'Fizz', @fizzbuzz.generate(3)
  end

  def test_5を渡したら文字列Buzzを返す
    assert_equal 'Buzz', @fizzbuzz.generate(5)
  end
end
----

[source, ruby]
----
class FizzBuzzTest < Minitest::Test
  describe 'FizzBuzz' do
    def setup
      @fizzbuzz = FizzBuzz
    end

    describe '三の倍数の場合' do
      def test_3を渡したら文字列Fizzを返す
        assert_equal 'Fizz', @fizzbuzz.generate(3)
      end
    end

    describe '五の倍数の場合' do
      def test_5を渡したら文字列Buzzを返す
        assert_equal 'Buzz', @fizzbuzz.generate(5)
      end
    end

    describe 'その他の場合' do
      def test_1を渡したら文字列1を返す
        assert_equal '1', @fizzbuzz.generate(1)
      end

      def test_2を渡したら文字列2を返す
        assert_equal '2', @fizzbuzz.generate(2)
      end
    end
  end
end
----

ここでは、*メソッドのインライン化* を適用してしてテストコードを読みやすくすることにしました。テストコードの *自己文書化* により動作する仕様書にすることができました。

[quote, '_テスト駆動開発_<<tdd>>']
____
混乱せずに読めるテストコードを目指すなら（コンピュータではなく人のためにテストを書いていることを忘れてはならない）、テストメソッドの長さは３行を目指そう。
____


[source, ruby]
----
$ ruby main.rb
$ git commit -m 'refactor: メソッドのインライン化'
----

さあ、*TODOリスト* もだいぶ消化されてきましたね。もうひと踏ん張りです。

TODOリスト

* [line-through]_数を文字列にして返す_
** [line-through]_1を渡したら文字列"1"を返す_
** [line-through]_2を渡したら文字列"2"を返す_
* [line-through]_3の倍数のときは数の代わりに｢Fizz｣と返す_
** [line-through]_3を渡したら文字列"Fizz"を返す_
* [line-through]_5 の倍数のときは｢Buzz｣と返す_
** [line-through]_5を渡したら文字列"Buzz"を返す_
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
** *15を渡したら文字列FizzBuzzを返す*
* 1 から 100 までの数
* プリントする

[source, ruby]
----
...
    describe '三と五の倍数の場合' do
      def test_15を渡したら文字列FizzBuzzを返す
        assert_equal 'FizzBuzz', @fizzbuzz.generate(15)
      end
    end
...
----

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero?
      result = 'Fizz'
    elsif number.modulo(5).zero?
      result = 'Buzz'
    elsif number.modulo(15).zero?
      result = 'FizzBuzz'
    end
    result
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 45982

 FAIL["test_15を渡したら文字列FizzBuzzを返す", #<Minitest::Reporters::Suite:0x00007f822c00b2b0 @name="FizzBuzz::三と五の倍数の場合">, 0.00231200000
0529224]
 test_15を渡したら文字列FizzBuzzを返す#FizzBuzz::三と五の倍数の場合 (0.00s)
        Expected: "FizzBuzz"
          Actual: "Fizz"
        main.rb:25:in `test_15を渡したら文字列FizzBuzzを返す'

  4/4: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00964s
4 tests, 4 assertions, 1 failures, 0 errors, 0 skips
----


おっと、調子に乗って *明白な実装* をしていたら怒られてしまいました。ここは一旦ギアを下げて小さなステップで何が問題かを調べることにしましょう。

[quote, '_テスト駆動開発_<<tdd>>']
____
明白な実装はセカンドギアだ。頭で考えていることがうまくコードに落とせないときは、ギアを下げる用意をしよう。
____

調べるにあたってコードを読んでもいいのですが、問題が発生したのは `15を渡したら文字列FizzBuzzを返す` テストを追加したあとですよね？ということは原因は追加したコードにあるはずですよね？よって、追加部分をデバッグすれば原因をすぐ発見できると思いませんか？

今回はRubyのデバッガとしてByebugをインストールして使うことにしましょう。

[source, bash]
----
$ gem install byebug
----

インストールが完了したら早速Byebugからプログラムを起動して動作を確認してみましょう。

[source, bash]
----
$ byebug main.rb

[1, 10] in /Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/main.rb
=>  1: require 'minitest/reporters'
    2: Minitest::Reporters.use!
    3: require 'minitest/autorun'
    4:
    5: class FizzBuzzTest < Minitest::Test
    6:   describe 'FizzBuzz' do
    7:     def setup
    8:       @fizzbuzz = FizzBuzz
    9:     end
   10:
(byebug)
----

詳しい操作に関しては https://qiita.com/jnchito/items/5aaf323ab4f24b526a61[printデバッグにさようなら！Ruby初心者のためのByebugチュートリアル^] を参照してください。

では、問題の原因を調査するためbyebugメソッドでコード内にブレークポイントを埋め込んでデバッガを実行してみましょう。

[source, ruby]
----
...
    describe '三と五の倍数の場合' do
      def test_15を渡したら文字列FizzBuzzを返す
        require 'byebug'
        byebug
        assert_equal 'FizzBuzz', @fizzbuzz.generate(15)
      end
    end
...
----

[source, bash]
----
$ byebug main.rb

[1, 10] in /Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/main.rb
=>  1: require 'minitest/reporters'
    2: Minitest::Reporters.use!
    3: require 'minitest/autorun'
    4:
    5: class FizzBuzzTest < Minitest::Test
    6:   describe 'FizzBuzz' do
    7:     def setup
    8:       @fizzbuzz = FizzBuzz
    9:     end
   10:
----

ブレークポイントまで `continue` コマンドで処理を進めます。`continue` コマンドは `c` でもいけます。
[source, bash]
----
(byebug) c
   22:
   23:     describe '三と五の倍数の場合' do
   24:       def test_15を渡したら文字列FizzBuzzを返す
   25:         require 'byebug'
   26:         byebug
=> 27:         assert_equal 'FizzBuzz', @fizzbuzz.generate(15)
   28:       end
   29:     end
   30:
   31:     describe 'その他の場合' do
----

続いて問題が発生した `@fizzbuzz.generate(15)` メソッド内にステップインします。
[source, bash]
----
(byebug) s
   36:   end
   37: end
   38:
   39: class FizzBuzz
   40:   def self.generate(number)
=> 41:     result = number.to_s
   42:     if number.modulo(3).zero?
   43:       result = 'Fizz'
   44:     elsif number.modulo(5).zero?
   45:       result = 'Buzz'
----

引数の `number` は `15` だから `elsif number.modulo(15).zero?` の行で判定されるはず・・・
[source, bash]
----
(byebug) s
   37: end
   38:
   39: class FizzBuzz
   40:   def self.generate(number)
   41:     result = number.to_s
=> 42:     if number.modulo(3).zero?
   43:       result = 'Fizz'
   44:     elsif number.modulo(5).zero?
   45:       result = 'Buzz'
   46:     elsif number.modulo(15).zero?
(byebug)
   38:
   39: class FizzBuzz
   40:   def self.generate(number)
   41:     result = number.to_s
   42:     if number.modulo(3).zero?
=> 43:       result = 'Fizz'
----

ファッ！？
[source, bash]
----
   44:     elsif number.modulo(5).zero?
   45:       result = 'Buzz'
   46:     elsif number.modulo(15).zero?
   47:       result = 'FizzBuzz'
(byebug) result
"15"
(byebug) q!
----

15は3で割り切れるから最初の判定で処理されますよね。まあ、常にコードに注意を払って頭の中で処理しながらコードを書いていればこんなミスすることは無いのでしょうが私はドジっ子プログラマなので計算機ができることは計算機にやらせて間違いがあれば原因を調べて解決するようにしています。とりあえず、テストを通るようにしておきましょう。

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero?
      result = 'Fizz'
      if number.modulo(15).zero?
        result = 'FizzBuzz'
      end
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end
    result
  end
end
----

テストが通ったのでコミットしておきます。コミットログにバグは残らないのですが作業の合間ではバグを作り込んでいましたよね。でも、テストがすぐに教えてくれるのですぐに修正することができました。結果として私のようなドジっ子プログラマでもバグの無いコードを書いているかのように見えるんですよ。

[source, bash]
----
$ ruby main.rb
$ git commit -m 'test: 15を渡したら文字列FizzBuzzを返す'
----

[quote, '_テスト駆動開発_<<tdd>>']
____
私はテスト駆動開発を長年行っているので、他人にミスを気づかれる前に、自分の誤りを修正できるだけなのだ。
____


先程のコードですが・・・

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero?
      result = 'Fizz'
      if number.modulo(15).zero?
        result = 'FizzBuzz'
      end
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end
    result
  end
end
----

*if文* の中でさらに *if文* をネストしています。いわゆる *コードの不吉な臭い* がしますね。ここは仕様の文言にある `3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントすること。` に沿った記述にするとともにネストした部分をわかりやすくするために *アルゴリズムの置き換え* を適用してリファクタリングをしましょう。

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero? && number.modulo(5).zero?
      result = 'FizzBuzz'
    elsif number.modulo(3).zero?
      result = 'Fizz'
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end
    result
  end
end
----

テストして、コミットです。

[source, bash]
----
$ ruby main.rb
$ git commit -m 'refactor: アルゴリズムの置き換え:'
----

==== 休憩

TODOリスト

* [line-through]_数を文字列にして返す_
** [line-through]_1を渡したら文字列"1"を返す_
** [line-through]_2を渡したら文字列"2"を返す_
* [line-through]_3の倍数のときは数の代わりに｢Fizz｣と返す_
** [line-through]_3を渡したら文字列"Fizz"を返す_
* [line-through]_5 の倍数のときは｢Buzz｣と返す_
** [line-through]_5を渡したら文字列"Buzz"を返す_
* [line-through]_3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す_
** [line-through]_15を渡したら文字列FizzBuzzを返す_
* *1 から 100 までの数*
* プリントする

数を引数にして文字列を返す `FizzBuzz::generate` メソッドはできたみたいですね。次のやることは・・・新しいメソッドを追加する必要がありそうですね。気分を切り替えるため少し休憩を取りましょう。

[quote, '_テスト駆動開発_<<tdd>>']
____
疲れたり手詰まりになったりしたときはどうすればいいだろうか----休憩を取ろう。
____

引き続き *TODOリスト* を片付けたいのですが `1から100までの数` を返すプログラムを書かないといけません。3を渡したらFizzのような *リテラル* を返すプログラムではなく 1から100までの *配列* を返すようなプログラムにする必要がありそうですね。TODOリストにするとこんな感じでしょうか。

TODOリスト

* 1 から 100 までの数の配列を返す
** 配列の初めは文字列の1を返す
** 配列の最後は文字列の100を返す
* プリントする

どうやら *配列* を返すプログラムを書かないと行けないようですね。え？ *明白な実装* の実装イメージがわかない。そんな時は *仮実装* からステップを小さくして始めるとしましょう。

[quote, '_テスト駆動開発_<<tdd>>']
____
何を書くべきかわかっているときは、明白な実装を行う。わからないときには仮実装を行う。まだ正しい実装が見えてこないなら、三角測量を行う。それでもまだわからないなら、シャワーを浴びに行こう。
____

==== 学習用テスト

*テストファースト* でまずRubyの *配列* の振る舞いを確認していきましょう。Rubyにおいて _配列とは複数のデータをまとめて格納できるオブジェクトのこと_<<pruby>> だそうです。空の配列を作るには `[]` (配列リテラル)を使えばいいみたいですね。こんな感じかな？

[source, ruby]
----
...
    describe '1から100までの数の配列を返す' do
      def test_配列の初めは文字列の1を返す
        result = []
        assert_equal '1', result
      end
    end
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 54004

 FAIL["test_配列の初めは文字列の1を返す", #<Minitest::Reporters::Suite:0x00007fd0fb93d540 @name="FizzBuzz::1から
100までの数の配列を返す">, 0.0016740000028221402]
 test_配列の初めは文字列の1を返す#FizzBuzz::1から100までの数の配列を返す (0.00s)
        Expected: "1"
          Actual: []
        main.rb:37:in `test_配列の初めは文字列の1を返す'

  5/5: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00602s
5 tests, 5 assertions, 1 failures, 0 errors, 0 skips
----

これは同値ではないのはわかりますね。ではこうしたらどうなるでしょうか？

[source, ruby]
----
...
    describe '1から100までの数の配列を返す' do
      def test_配列の初めは文字列の1を返す
        result = ['1']
        assert_equal '1', result
      end
    end
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 32701

 FAIL["test_配列の初めは文字列の1を返す", #<Minitest::Reporters::Suite:0x00007fb36f096030 @name="FizzBuzz::1から100までの数の配列を返す">, 0.0018850000014936086]
 test_配列の初めは文字列の1を返す#FizzBuzz::1から100までの数の配列を返す (0.00s)
        Expected: "1"
          Actual: ["1"]
        main.rb:38:in `test_配列の初めは文字列の1を返す'

  5/5: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.04383s
5 tests, 5 assertions, 1 failures, 0 errors, 0 skips
----

*配列* は _要素の変更、追加、削除_<<pruby>> で内容を色々操作できそうですね。でも、いちいちテストコードを編集してテストを実行させるのも面倒なのでここはデバッガを使ってみましょう。まずブレークポイントを設定して・・・

[source, ruby]
----
...
    describe '1から100までの数の配列を返す' do
      def test_配列の初めは文字列の1を返す
        require 'byebug'
        byebug
        result = ['1']
        assert_equal '1', result
      end
    end
  end
end
----

デバッガを起動します。

[source, bash]
----
$ byebug main.rb 

[1, 10] in /Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/main.rb
=>  1: require 'minitest/reporters'
    2: Minitest::Reporters.use!
    3: require 'minitest/autorun'
    4: 
    5: class FizzBuzzTest < Minitest::Test
    6:   describe 'FizzBuzz' do
    7:     def setup
    8:       @fizzbuzz = FizzBuzz
    9:     end
   10: 
(byebug) 
----

continueでブレークポイントまで進めます。

[source, bash]
----
(byebug) c
Started with run options --seed 15764

  /0: [=---=---=---=---=---=---=---=---=---=---=---=---=---=---=---=---=---=-] 0% Time: 00:00:00,  ETA: ??:??:??
[34, 43] in /Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/main.rb
   34: 
   35:     describe '1から100までの数の配列を返す' do
   36:       def test_配列の初めは文字列の1を返す
   37:         require 'byebug'
   38:         byebug
=> 39:         result = ['1']
   40:         assert_equal '1', result
   41:       end
   42:     end
   43:   end
----

ステップインして `result` の中身を確認してみましょう。

[source, bash]
----
(byebug) s

[35, 44] in /Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/main.rb
   35:     describe '1から100までの数の配列を返す' do
   36:       def test_配列の初めは文字列の1を返す
   37:         require 'byebug'
   38:         byebug
   39:         result = ['1']
=> 40:         assert_equal '1', result
   41:       end
   42:     end
   43:   end
   44: end
(byebug) result
["1"]
----

添字を指定して *配列* の最初の文字列を確認してみましょう。

[source, bash]
----
(byebug) result
["1"]
(byebug) result[1]
nil
----

おや？１番目は"1"では無いようですね。*配列* は0から始まるので1番目を指定するにはこうします。

[source, bash]
----
(byebug) result
["1"]
(byebug) result[1]
nil
(byebug) result[0]
"1"
----

続いて、複数の文字列から構成される *配列* を作ってみましょう。


[source, bash]
----
(byebug) result = ['1','2','3']
["1", "2", "3"]
(byebug) result[0]
"1"
(byebug) result[2]
"3"
----

ちなみにRubyだとこのように表記することができます。直感的でわかりやすくないですか？

[source, bash]
----
(byebug) result
["1", "2", "3"]
(byebug) result.first
"1"
(byebug) result.last
"3"
----

最後に追加、削除、変更をやってみましょう。

[source, bash]
----
(byebug) result = ['1','2','3']
["1", "2", "3"]
(byebug) result << '4'
["1", "2", "3", "4"]
(byebug) result.push('4')
["1", "2", "3", "4", "4"]
(byebug) result.delete_at(3)
"4"
(byebug) result
["1", "2", "3", "4"]
(byebug) result[2] = '30'
"30"
(byebug) result
["1", "2", "30", "4"]
----

*配列* の振る舞いもだいぶイメージできたのでデバッガを終了させてテストコードを少し変えてみましょう。

[source, bash]
----
(byebug) q
Really quit? (y/n) y
----

[source, ruby]
----
...
    describe '1から100までの数の配列を返す' do
      def test_配列の初めは文字列の1を返す
        result = ['1', '2', '3']
        assert_equal '1', result.first
        assert_equal '2', result[1]
        assert_equal '3', result.last
      end
    end
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 39118

  5/5: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00186s
5 tests, 7 assertions, 0 failures, 0 errors, 0 skips
----

`result` に配列を返すメソッドを作れば良さそうですね。とりあえずメソッド名は今の時点ではあまり考えずに・・・

[source, ruby]
----
...
    describe '1から100までの数の配列を返す' do
      def test_配列の初めは文字列の1を返す
        result = FizzBuzz.print_1_to_100
        assert_equal '1', result.first
      end
    end
  end
end
----

[source, bash]
----
$ ruby main.rb 
Started with run options --seed 19247

ERROR["test_配列の初めは文字列の1を返す", #<Minitest::Reporters::Suite:0x00007faaea925058 @name="FizzBuzz::1から
100までの数の配列を返す">, 0.0017889999980980065]
 test_配列の初めは文字列の1を返す#FizzBuzz::1から100までの数の配列を返す (0.00s)
NoMethodError:         NoMethodError: undefined method `print_1_to_100' for FizzBuzz:Class
            main.rb:37:in `test_配列の初めは文字列の1を返す'

  5/5: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00454s
5 tests, 4 assertions, 0 failures, 1 errors, 0 skips
----

ここまでくれば *仮実装* はできますね。

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero? && number.modulo(5).zero?
      result = 'FizzBuzz'
    elsif number.modulo(3).zero?
      result = 'Fizz'
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end
    result
  end

  def self.print_1_to_100
    [1, 2, 3]
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 24564

 FAIL["test_配列の初めは文字列の1を返す", #<Minitest::Reporters::Suite:0x00007fefd8917060 @name="FizzBuzz::1から
100までの数の配列を返す">, 0.0011969999977736734]
 test_配列の初めは文字列の1を返す#FizzBuzz::1から100までの数の配列を返す (0.00s)
        Expected: "1"
          Actual: 1
        main.rb:38:in `test_配列の初めは文字列の1を返す'

  5/5: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00209s
5 tests, 5 assertions, 1 failures, 0 errors, 0 skips
----

ファッ！？、ああ、数字ではなく文字列で返すのだからこうですね。

[source, ruby]
----
...
  def self.print_1_to_100
    ['1', '2', '3']
  end
end
----

*%記法* を使ってRubyらしく書くならこうですね。

[source, ruby]
----
...
  def self.print_1_to_100
    %w[1 2 3]
  end
end
----


[source, bash]
----
$ ruby main.rb
Started with run options --seed 42995

  5/5: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00195s
5 tests, 5 assertions, 0 failures, 0 errors, 0 skips
----


*TODOリスト*　の１つ目を *仮実装* で片づけことができました。ちなみにテストコードを使ってソフトウェアの振る舞いを検証するテクニックを *学習用テスト* と言います。

[quote, '_テスト駆動開発_<<tdd>>']
____
学習用テスト

チーム外の誰かが書いたソフトウェアのテストを書くのはどのようなときか----そのソフトウェアの新機能を初めて使う際に書いてみよう。
____


TODOリスト

* 1 から 100 までの数の配列を返す
** [line-through]*配列の初めは文字列の1を返す*
** 配列の最後は文字列の100を返す
* プリントする

`FizzBuzz::print_1_to_100` メソッドはまだ最後の要素が検証されていませんね。*三角測量* で小さなステップで進めていくことにしましょう。

[source, ruby]
----
...
    describe '1から100までの数の配列を返す' do
      def test_配列の初めは文字列の1を返す
        result = FizzBuzz.print_1_to_100
        assert_equal '1', result.first
      end

      def test_配列の最後は文字列の100を返す
        result = FizzBuzz.print_1_to_100
        assert_equal '100', result.last
      end
    end
  end
end
----

[source, bash]
----
$ ruby main.rb 
Started with run options --seed 12031

 FAIL["test_配列の最後は文字列の100を返す", #<Minitest::Reporters::Suite:0x00007fccc9828500 @name="FizzBuzz::1から100までの数の配列を返す">, 0.0018540000019129366]
 test_配列の最後は文字列の100を返す#FizzBuzz::1から100までの数の配列を返す (0.00s)
        Expected: "100"
          Actual: "3"
        main.rb:43:in `test_配列の最後は文字列の100を返す'

  6/6: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.02936s
----

配列は3までなので想定通りテストは失敗します。さて、1から100までの文字列で構成される配列をどうやって作りましょうか？ 先程は *if文* を使って *条件分岐* をプログラムで実行しました。今回は *繰り返し処理* をプログラムで実行する必要がありそうですね。Rubyの繰り返し処理は _配列のeachメソッドが繰り返し処理処理を実行している_<<pruby>> そうです。とはいえ、実際に動かして振る舞いを確認しないとイメージは難しいですよね。 *学習用テスト* を書いてもいいのですが今回は _irb上で簡単なコードを動かしてみる_<<pruby>>ことで振る舞いを検証してみましょう。まずコマンドラインで `irb` を起動します。

[source, bash]
----
$ irb
irb(main):001:0> 
----

まず先程デバッガでやった配列の作成をやってみましょう。

[source, bash]
----
irb(main):001:0> result = %w[1 2 3]
=> ["1", "2", "3"]
----

配列のeachメソッドをつかって配列の中身を繰り返し処理で表示させてみましょう。`p` はプリントメソッドです。

[source, bash]
----
irb(main):003:0> result.each do |n| p n end
"1"
"2"
"3"
=> ["1", "2", "3"]
----

配列の中身を繰り返し処理で取り出す方法はわかりました。あとは100までの配列をどうやって作ればよいのでしょうか？ `['1','2','3'...'100']` と手書きで作りますか？100件ぐらいならまあできなくもないでしょうが1000件,10000件ならどうでしょうか？無理ですね。計算機にやってもらいましょう、_Rubyには「１から５まで」「文字'a'から文字'e'まで」のように、値の範囲を表すオブジェクトがあります。これを範囲オブジェクトと言います。_<<pruby>>、おあつらえ向きの方法が用意されているみたいですね *範囲(Range)* 使いましょう。

[source, bash]
----
irb(main):008:0> (1..5).each do |n| p n end
1
2
3
4
5
=> 1..5
irb(main):009:0> (1...5).each do |n| p n end
1
2
3
4
----

100まで表示したいのでこうですね。

[source, bash]
----
irb(main):010:0> (1..100).each do |n| p n end
1
2
3
..
99
100
=> 1..100
----

`FizzBuzz::print_1_to_100` メソッドの *明白な実装* イメージができましたか？ `irb` を終了させてプロダクトコードを変更しましょう。

[source, bash]
----
irb(main):011:0> exit
----

[source, ruby]
----
...
  def self.print_1_to_100
    result = []
    (1..100).each do |n|
      result << n
    end
    result
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 38412

 FAIL["test_配列の初めは文字列の1を返す", #<Minitest::Reporters::Suite:0x00007f858480edf8 @name="FizzBuzz::1から
100までの数の配列を返す">, 0.0012219999989611097]
 test_配列の初めは文字列の1を返す#FizzBuzz::1から100までの数の配列を返す (0.00s)
        Expected: "1"
          Actual: 1
        main.rb:38:in `test_配列の初めは文字列の1を返す'

 FAIL["test_配列の最後は文字列の100を返す", #<Minitest::Reporters::Suite:0x00007f858480c8f0 @name="FizzBuzz::1から100までの数の配列を返す">, 0.0014040000023669563]
 test_配列の最後は文字列の100を返す#FizzBuzz::1から100までの数の配列を返す (0.00s)
        Expected: "100"
          Actual: 100
        main.rb:43:in `test_配列の最後は文字列の100を返す'

  6/6: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00218s
6 tests, 6 assertions, 2 failures, 0 errors, 0 skips
----

ファッ！？また、やらかしました。文字列に変換しなといけませんね。

[source, ruby]
----
...
  def self.print_1_to_100
    result = []
    (1..100).each do |n|
      result << n.to_s
    end
    result
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 40179

  6/6: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00196s
6 tests, 6 assertions, 0 failures, 0 errors, 0 skips
----

ちなみに、_do ... endを使う代わりに、{}で囲んでもブロックを作れる_<<pruby>> のでこのように書き換えれます。

[source, ruby]
----
...
  def self.print_1_to_100
    result = []
    (1..100).each { |n| result << n.to_s }
    result
  end
end
----

ここで、一旦コミットしておきましょう。

[source, bash]
----
$ git commit -m 'test: 1から100までの数を返す'
----

TODOリスト

* 1 から 100 までの数の配列を返す
** [line-through]_配列の初めは文字列の1を返す_
** [line-through]*配列の最後は文字列の100を返す*
* プリントする

1から100までの数の配列を返すメソッドはできました。しかし、このプログラムは1から100までの数を `FizzBuzz::generate` した結果を返すのが正しい振る舞いですよね。 *TODOリスト* を追加してテストも追加します。

TODOリスト

* 1 から 100 までの数の配列を返す
** [line-through]_配列の初めは文字列の1を返す_
** [line-through]_配列の最後は文字列の100を返す_
** *配列の2番めは文字列のFizzを返す*
* プリントする

[source, ruby]
----
...
      def test_配列の2番目は文字列のをFizz返す
        result = FizzBuzz.print_1_to_100
        assert_equal 'Fizz', result[2]
      end
    end
  end
end
----

[source, ruby]
----
$ ruby main.rb
Started with run options --seed 50411

 FAIL["test_配列の2番目は文字列のをFizz返す", #<Minitest::Reporters::Suite:0x00007fe8a1917dc8 @name="FizzBuzz::1から100までの数の配列を返す">, 0.01608900000428548]
 test_配列の2番目は文字列のをFizz返す#FizzBuzz::1から100までの数の配列を返す (0.02s)
        --- expected
        +++ actual
        @@ -1 +1,3 @@
        -"Fizz"
        +# encoding: US-ASCII
        +#    valid: true
        +"3"
        main.rb:48:in `test_配列の2番目は文字列のをFizz返す'

  7/7: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.03112s
7 tests, 7 assertions, 1 failures, 0 errors, 0 skips
----

ですよね、ここは *繰り返し処理* のなかで `FizzBuzz::generate` を呼び出すように変更しましょう。

[source, ruby]
----
...
  def self.print_1_to_100
    result = []
    (1..100).each { |n| result << generate(n) }
    result
  end
end
----

[source, ruby]
----
$ ruby main.rb
Started with run options --seed 15549

 FAIL["test_配列の最後は文字列の100を返す", #<Minitest::Reporters::Suite:0x00007ff80a907e28 @name="FizzBuzz::1から100までの数の配列を返す">, 0.001347000004898291]
 test_配列の最後は文字列の100を返す#FizzBuzz::1から100までの数の配列を返す (0.00s)
        Expected: "100"
          Actual: "Buzz"
        main.rb:43:in `test_配列の最後は文字列の100を返す'

  7/7: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00218s
7 tests, 7 assertions, 1 failures, 0 errors, 0 skips
----


新規に追加したテストはパスしたのですが２つ目のテストが失敗しています。これはテストケースが間違っていますね。

[source, ruby]
----
...
      def test_配列の最後は文字列のBuzzを返す
        result = FizzBuzz.print_1_to_100
        assert_equal 'Buzz', result.last
      end

      def test_配列の2番目は文字列のをFizz返す
        result = FizzBuzz.print_1_to_100
        assert_equal 'Fizz', result[2]
      end
    end
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 21247

  7/7: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00217s
7 tests, 7 assertions, 0 failures, 0 errors, 0 skips
----

他のパターンも明記しておきたいですよね。

[source, ruby]
----
...
    describe '1から100までのFizzBuzzの配列を返す' do
      def test_配列の初めは文字列の1を返す
        result = FizzBuzz.print_1_to_100
        assert_equal '1', result.first
      end

      def test_配列の最後は文字列のBuzzを返す
        result = FizzBuzz.print_1_to_100
        assert_equal 'Buzz', result.last
      end

      def test_配列の2番目は文字列のをFizz返す
        result = FizzBuzz.print_1_to_100
        assert_equal 'Fizz', result[2]
      end

      def test_配列の4番目は文字列のをBuzz返す
        result = FizzBuzz.print_1_to_100
        assert_equal 'Buzz', result[4]
      end

      def test_配列の14番目は文字列のをFizzBuzz返す
        result = FizzBuzz.print_1_to_100
        assert_equal 'FizzBuzz', result[14]
      end
    end
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 17460

  9/9: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00207s
9 tests, 9 assertions, 0 failures, 0 errors, 0 skips
----

とりあえず、現時点で仕様を満たすプログラムにはなったみたいですね。

[source, bash]
----
$ git commit -m 'test: 1から100までのFizzBuzzの配列を返す'
----

TODOリスト

* [line-through]*1 から 100 までのFizzBuzzの配列を返す*
** [line-through]_配列の初めは文字列の1を返す_
** [line-through]_配列の最後は文字列の100を返す_
** [line-through]_配列の2番めは文字列のFizzを返す_
** [line-through]_配列の4番目は文字列のBuzzを返す_
** [line-through]_配列の14番目は文字列のFizzBuzzを返す_
* プリントする

まだリファクタリングが残っているのですがその前にRubyの配列メソッドの理解をもう少し深めたいので *学習用テスト* を追加しましょう。

[source, ruby]
----
...
  describe '配列や繰り返し処理を理解する' do
    def test_繰り返し処理
      $stdout = StringIO.new
      [1, 2, 3].each { |i| p i * i }
      output = $stdout.string

      assert_equal "1\n" + "4\n" + "9\n", output
    end

    def test_特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].select(&:integer?)
      assert_equal [2, 4], result
    end

    def test_特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].find_all(&:integer?)
      assert_equal [2, 4], result
    end

    def test_特定の条件を満たさない要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].reject(&:integer?)
      assert_equal [1.1, 3.3], result
    end

    def test_新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].map(&:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].collect(&:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].find(&:size)
      assert_equal 'apple', result
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].detect(&:size)
      assert_equal 'apple', result
    end

    def test_指定した評価式で並び変えた配列を返す
      assert_equal %w[1 10 13 2 3 4], %w[2 4 13 3 1 10].sort
      assert_equal %w[1 2 3 4 10 13],
                   %w[2 4 13 3 1 10].sort { |a, b| a.to_i <=> b.to_i }
      assert_equal %w[13 10 4 3 2 1],
                   %w[2 4 13 3 1 10].sort { |b, a| a.to_i <=> b.to_i }
    end

    def test_配列の中から、条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry apricot].grep(/^a/)
      assert_equal %w[apple apricot], result
    end

    def test_ブロック内の条件式が真である間までの要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9].take_while { |item| item < 6 }
      assert_equal [1, 2, 3, 4, 5], result
    end

    def test_ブロック内の条件式が真である以降の要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].drop_while { |item| item < 6 }
      assert_equal [6, 7, 8, 9, 10], result
    end

    def test_畳み込み演算を行う
      result = [1, 2, 3, 4, 5].inject(0) { |total, n| total + n }
      assert_equal 15, result
    end

    def test_畳み込み演算を行う
      result = [1, 2, 3, 4, 5].reduce { |total, n| total + n }
      assert_equal 15, result
    end
  end
end
----

[source, bash]
----
$ ruby main.rb 
Started with run options --seed 18136

  19/19: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00307s
19 tests, 21 assertions, 0 failures, 0 errors, 0 skips
----

[source, bash]
----
$ git commit -m 'test: 学習用テスト'
----

==== コードの不吉な臭い

[quote, '_テスト駆動開発_<<tdd>>']
____
開発を終えるまでに考えつくまでに考えつく限りのテストを書き、テストに支えられたリファクタリングが、網羅性のあるテストに支えられてたリファクタリングになるようにしなければならない。
____

===== 不思議な名前

===== 長い関数

===== ループ

==== 動作するきれいなコード


[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s

    if number.modulo(3).zero? && number.modulo(5).zero?
      result = 'FizzBuzz'
    elsif number.modulo(3).zero?
      result = 'Fizz'
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end

    result
  end
...:
----

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s

    return 'FizzBuzz' if number.modulo(3).zero? && number.modulo(5).zero?
    return 'Fizz' if number.modulo(3).zero?
    return 'Buzz' if number.modulo(5).zero?

    result
  end
...
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 24552

  9/9: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.04318s
9 tests, 9 assertions, 0 failures, 0 errors, 0 skips
----

[source, bash]
----
$ git commit -m 'refactor: ガード節による入れ子条件の置き換え'
----


[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s

    return 'FizzBuzz' if number.modulo(3).zero? && number.modulo(5).zero?
    return 'Fizz' if number.modulo(3).zero?
    return 'Buzz' if number.modulo(5).zero?

    result
  end
...
----

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    return 'FizzBuzz' if number.modulo(3).zero? && number.modulo(5).zero?
    return 'Fizz' if number.modulo(3).zero?
    return 'Buzz' if number.modulo(5).zero?
    number.to_s
  end
...
----

[source, bash]
----
$ ruby main.rb
$ git commit -m 'refactor:　変数のインライン化'
----

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    return 'FizzBuzz' if number.modulo(3).zero? && number.modulo(5).zero?
    return 'Fizz' if number.modulo(3).zero?
    return 'Buzz' if number.modulo(5).zero?
    number.to_s
  end
...
----

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz && is_buzz
    return 'Fizz' if is_fizz
    return 'Buzz' if is_buzz
    number.to_s
  end
...
----

[source, bash]
----
$ ruby main.rb
$ git commit -m 'refactor:　変数の抽出'
----

[source, ruby]
----
class FizzBuzz
...
  def self.print_1_to_100
    result = []

    (1..100).each { |i| result.push(generate(i)) }

    result
  end
end
----

[source, ruby]
----
class FizzBuzz
...
  def self.generate_list
    result = []

    (1..100).each { |i| result.push(generate(i)) }

    result
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 23868

ERROR["test_14番目は文字列FizzBuzzを返す", #<Minitest::Reporters::Suite:0x00007ff0d918a368 @name="FizzBuzz::1から100までの数を返す">, 0.0013330000001587905]
 test_14番目は文字列FizzBuzzを返す#FizzBuzz::1から100までの数を返す (0.00s)
NoMethodError:         NoMethodError: undefined method `print_1_to_100' for FizzBuzz:Class
            main.rb:37:in `setup'

ERROR["test_4番目は文字列Buzzを返す", #<Minitest::Reporters::Suite:0x00007ff0d985dd48 @name="FizzBuzz::1から100までの数を返す">, 0.003452000000834232]
 test_4番目は文字列Buzzを返す#FizzBuzz::1から100までの数を返す (0.00s)
NoMethodError:         NoMethodError: undefined method `print_1_to_100' for FizzBuzz:Class
            main.rb:37:in `setup'

ERROR["test_はじめは文字列1を返す", #<Minitest::Reporters::Suite:0x00007ff0d91914b0 @name="FizzBuzz::1から100までの数を返す">, 0.006145000001197332]
 test_はじめは文字列1を返す#FizzBuzz::1から100までの数を返す (0.01s)
NoMethodError:         NoMethodError: undefined method `print_1_to_100' for FizzBuzz:Class
            main.rb:37:in `setup'

ERROR["test_2番目は文字列Fizzを返す", #<Minitest::Reporters::Suite:0x00007ff0da87dca0 @name="FizzBuzz::1から100までの数を返す">, 0.008593000000473694]
 test_2番目は文字列Fizzを返す#FizzBuzz::1から100までの数を返す (0.01s)
NoMethodError:         NoMethodError: undefined method `print_1_to_100' for FizzBuzz:Class
            main.rb:37:in `setup'

ERROR["test_最後は文字列Buzzを返す", #<Minitest::Reporters::Suite:0x00007ff0da8597d8 @name="FizzBuzz::1から100までの数を返す">, 0.045028000000456814]
 test_最後は文字列Buzzを返す#FizzBuzz::1から100までの数を返す (0.05s)
NoMethodError:         NoMethodError: undefined method `print_1_to_100' for FizzBuzz:Class
            main.rb:37:in `setup'

  9/9: [======================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.04876s
9 tests, 4 assertions, 0 failures, 5 errors, 0 skips
----

[source, ruby]
----
class FizzBuzzTest < Minitest::Test
...
    describe '1から100までの数を返す' do
      def setup
        @result = FizzBuzz.generate_list
      end
...
----

[source, bash]
----
$ ruby main.rb
$ git commit -m 'refactor:　メソッド名の変更'
----

[source, ruby]
----
class FizzBuzz
...
  def self.generate_list
    (1..100).each { |i| result.push(generate(i)) }
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 28039

ERROR["test_14番目は文字列FizzBuzzを返す", #<Minitest::Reporters::Suite:0x00007f85a88b5670 @name="FizzBuzz::1から100までの数を返す">, 0.001374999999825377]
 test_14番目は文字列FizzBuzzを返す#FizzBuzz::1から100までの数を返す (0.00s)
NameError:         NameError: undefined local variable or method `result' for FizzBuzz:Class
            main.rb:75:in `block in generate_list'
            main.rb:75:in `each'
            main.rb:75:in `generate_list'
            main.rb:37:in `setup'

ERROR["test_4番目は文字列Buzzを返す", #<Minitest::Reporters::Suite:0x00007f85a88c70f0 @name="FizzBuzz::1から100までの数を返す">, 0.002824999999575084]
 test_4番目は文字列Buzzを返す#FizzBuzz::1から100までの数を返す (0.00s)
NameError:         NameError: undefined local variable or method `result' for FizzBuzz:Class
            main.rb:75:in `block in generate_list'
            main.rb:75:in `each'
            main.rb:75:in `generate_list'
            main.rb:37:in `setup'

ERROR["test_2番目は文字列Fizzを返す", #<Minitest::Reporters::Suite:0x00007f859f070540 @name="FizzBuzz::1から100までの数を返す">, 0.0041270000001532026]
 test_2番目は文字列Fizzを返す#FizzBuzz::1から100までの数を返す (0.00s)
NameError:         NameError: undefined local variable or method `result' for FizzBuzz:Class
            main.rb:75:in `block in generate_list'
            main.rb:75:in `each'
            main.rb:75:in `generate_list'
            main.rb:37:in `setup'

ERROR["test_はじめは文字列1を返す", #<Minitest::Reporters::Suite:0x00007f856f804638 @name="FizzBuzz::1から100までの数を返す">, 0.03712699999960023]
 test_はじめは文字列1を返す#FizzBuzz::1から100までの数を返す (0.04s)
NameError:         NameError: undefined local variable or method `result' for FizzBuzz:Class
            main.rb:75:in `block in generate_list'
            main.rb:75:in `each'
            main.rb:75:in `generate_list'
            main.rb:37:in `setup'

ERROR["test_最後は文字列Buzzを返す", #<Minitest::Reporters::Suite:0x00007f856e8046e8 @name="FizzBuzz::1から100までの数を返す">, 0.0393739999999525]
 test_最後は文字列Buzzを返す#FizzBuzz::1から100までの数を返す (0.04s)
NameError:         NameError: undefined local variable or method `result' for FizzBuzz:Class
            main.rb:75:in `block in generate_list'
            main.rb:75:in `each'
            main.rb:75:in `generate_list'
            main.rb:37:in `setup'

  9/9: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.04360s
9 tests, 4 assertions, 0 failures, 5 errors, 0 skips
----

[source, ruby]
----
class FizzBuzz
...
  def self.generate_list
    (1..100).each { |i| generate(i) }
  end
end
----


[source, bash]
----
$ ruby main.rb
Started with run options --seed 13473

 FAIL["test_最後は文字列Buzzを返す", #<Minitest::Reporters::Suite:0x00007fbbc50574d0 @name="FizzBuzz::1から100までの数を返す">, 0.0016329999998561107]
 test_最後は文字列Buzzを返す#FizzBuzz::1から100までの数を返す (0.00s)
        Expected: "Buzz"
          Actual: 100
        main.rb:45:in `test_最後は文字列Buzzを返す'

ERROR["test_14番目は文字列FizzBuzzを返す", #<Minitest::Reporters::Suite:0x00007fbbc50a6a80 @name="FizzBuzz::1から100までの数を返す">, 0.001825999999709893]
 test_14番目は文字列FizzBuzzを返す#FizzBuzz::1から100までの数を返す (0.00s)
NoMethodError:         NoMethodError: undefined method `[]' for 1..100:Range
            main.rb:57:in `test_14番目は文字列FizzBuzzを返す'

 FAIL["test_はじめは文字列1を返す", #<Minitest::Reporters::Suite:0x00007fbbc50ad330 @name="FizzBuzz::1から100までの数を返す">, 0.002407999998467858]
 test_はじめは文字列1を返す#FizzBuzz::1から100までの数を返す (0.00s)
        Expected: "1"
          Actual: 1
        main.rb:41:in `test_はじめは文字列1を返す'

ERROR["test_2番目は文字列Fizzを返す", #<Minitest::Reporters::Suite:0x00007fbba5016c20 @name="FizzBuzz::1から100までの数を返す">, 0.02718299999833107]
 test_2番目は文字列Fizzを返す#FizzBuzz::1から100までの数を返す (0.03s)
NoMethodError:         NoMethodError: undefined method `[]' for 1..100:Range
            main.rb:49:in `test_2番目は文字列Fizzを返す'

ERROR["test_4番目は文字列Buzzを返す", #<Minitest::Reporters::Suite:0x00007fbba502dbc8 @name="FizzBuzz::1から100までの数を返す">, 0.027986999999484397]
 test_4番目は文字列Buzzを返す#FizzBuzz::1から100までの数を返す (0.03s)
NoMethodError:         NoMethodError: undefined method `[]' for 1..100:Range
            main.rb:53:in `test_4番目は文字列Buzzを返す'

  9/9: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.02914s
9 tests, 6 assertions, 2 failures, 3 errors, 0 skips
----


[source, ruby]
----
class FizzBuzz
...
  def self.generate_list
    (1..100).each { |i| generate(i) }
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 27662

  9/9: [======================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00221s
9 tests, 9 assertions, 0 failures, 0 errors, 0 skips
----

[source, bash]
----
$ git commit -m 'refactor: パイプラインによるループの置き換え'
----

学習用テスト

[source, ruby]
----
  describe '配列や繰り返し処理を理解する' do
    def test_繰り返し処理
      $stdout = StringIO.new
      [1, 2, 3].each { |i| p i * i }
      output = $stdout.string

      assert_equal "1\n" + "4\n" + "9\n", output
    end

    def test_特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].select(&:integer?)
      assert_equal [2, 4], result
    end

    def test_特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].find_all(&:integer?)
      assert_equal [2, 4], result
    end

    def test_特定の条件を満たさない要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].reject(&:integer?)
      assert_equal [1.1, 3.3], result
    end

    def test_新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].map(&:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].collect(&:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].find(&:size)
      assert_equal 'apple', result
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].detect(&:size)
      assert_equal 'apple', result
    end

    def test_指定した評価式で並び変えた配列を返す
      assert_equal %w[1 10 13 2 3 4], %w[2 4 13 3 1 10].sort
      assert_equal %w[1 2 3 4 10 13],
                   %w[2 4 13 3 1 10].sort { |a, b| a.to_i <=> b.to_i }
      assert_equal %w[13 10 4 3 2 1],
                   %w[2 4 13 3 1 10].sort { |b, a| a.to_i <=> b.to_i }
    end

    def test_配列の中から、条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry apricot].grep(/^a/)
      assert_equal %w[apple apricot], result
    end

    def test_ブロック内の条件式が真である間までの要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9].take_while { |item| item < 6 }
      assert_equal [1, 2, 3, 4, 5], result
    end

    def test_ブロック内の条件式が真である以降の要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].drop_while { |item| item < 6 }
      assert_equal [6, 7, 8, 9, 10], result
    end

    def test_畳み込み演算を行う
      result = [1, 2, 3, 4, 5].inject(0) { |total, n| total + n }
      assert_equal 15, result
    end

    def test_畳み込み演算を行う
      result = [1, 2, 3, 4, 5].reduce { |total, n| total + n }
      assert_equal 15, result
    end
  end
----

[source, bash]
----
$ git commit -m 'test: 学習用テスト'
----

[source, ruby]
----
class FizzBuzz
...
  def self.generate_list
    (1..100).each { |i| generate(i) }
  end
end
----

[source, ruby]
----
class FizzBuzz
  MAX_NUMBER = 100
...
  def self.generate_list
    (1..MAX_NUMBER).map { |i| generate(i) }
  end
end
----

[source, bash]
----
$ ruby main.rb
$ git commit -m 'refactor: マジックナンバーの置き換え'
----

TODOリスト
- [x] 数を文字列にして返す
 - [x] 1を渡したら文字列"1"を返す
 - [x] 2を渡したら文字列"2"を返す
- [x] 3 の倍数のときは数の代わりに｢Fizz｣と返す
 - [x] 3を渡したら文字列"Fizz"を返す
- [x] 5 の倍数のときは｢Buzz｣と返す
 - [x] 5を渡したら文字列"Buzz"を返す
- [x] 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
 - [x] 15を渡したら文字列"FizzBuzz"を返す
- [x] 1 から 100 までの数を返す
  - [x] はじめは文字列1を返す
  - [x] 最後は文字列Buzzを返す
  - [x] 2番目は文字列Fizzを返す
  - [x] 4番目は文字列Buzzを返す
  - [x] 14番目は文字列FizzBuzzを返す
- [ ] プリントする

[source, ruby]
----
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz && is_buzz
    return 'Fizz' if is_fizz
    return 'Buzz' if is_buzz
    number.to_s
  end

  def self.generate_list
    (1..MAX_NUMBER).map { |i| generate(i) }
  end
end

puts FizzBuzz.generate_list
----

[source, bash]
----
$ ruby main.rb 
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
26
Fizz
28
29
FizzBuzz
31
32
Fizz
34
Buzz
Fizz
37
38
Fizz
Buzz
41
Fizz
43
44
FizzBuzz
46
47
Fizz
49
Buzz
Fizz
52
53
Fizz
Buzz
56
Fizz
58
59
FizzBuzz
61
62
Fizz
64
Buzz
Fizz
67
68
Fizz
Buzz
71
Fizz
73
74
FizzBuzz
76
77
Fizz
79
Buzz
Fizz
82
83
Fizz
Buzz
86
Fizz
88
89
FizzBuzz
91
92
Fizz
94
Buzz
Fizz
97
98
Fizz
Buzz
Started with run options --seed 48518

  19/19: [====================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00834s
19 tests, 21 assertions, 0 failures, 0 errors, 0 skips
----

[source, bash]
----
$ git commit -m 'feat: FizzBuzz'
----

TODOリスト

- [x] 数を文字列にして返す
 - [x] 1を渡したら文字列"1"を返す
 - [x] 2を渡したら文字列"2"を返す
- [x] 3 の倍数のときは数の代わりに｢Fizz｣と返す
 - [x] 3を渡したら文字列"Fizz"を返す
- [x] 5 の倍数のときは｢Buzz｣と返す
 - [x] 5を渡したら文字列"Buzz"を返す
- [x] 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
 - [x] 15を渡したら文字列"FizzBuzz"を返す
- [x] 1 から 100 までの数を返す
  - [x] はじめは文字列1を返す
  - [x] 最後は文字列Buzzを返す
  - [x] 2番目は文字列Fizzを返す
  - [x] 4番目は文字列Buzzを返す
  - [x] 14番目は文字列FizzBuzzを返す
- [x] プリントする

== エピソード2
=== 継続的インテグレーションから始まるテスト駆動開発

=== オブジェクト指向から始まるテスト駆動開発
==== TODOリスト作成
==== タイプ1の場合
==== タイプ2の場合
==== タイプ3の場合
==== フィールドのカプセル化
==== ポリモーフィズムによる条件記述の置き換え
==== スーパークラスの抽出
==== オブジェクトによるプリミティブの置き換え
==== アサーションの導入
==== 例外によるエラーコードの置き換え
==== モジュールの分割

== エピソード3
=== クライアント開発から始まるテスト駆動開発
==== APIサービスを作る
==== APIサービスと連携する
==== UIを作る
==== UIとAPIサービスを連携する

== エピソード4
=== 本番運用から始まるテスト駆動開発
==== E2Eテストのセットアップ
==== クライアントモジュールの分割
==== 本番環境と開発環境で表示を切り返る
==== コードレビュー

== 参照

=== 参考サイト

- https://channel9.msdn.com/Events/de-code/2017/DO03?ocid=player[50 分でわかるテスト駆動開発^]
- https://backlog.com/ja/git-tutorial/[サルでもわかるGit入門〜バージョン管理を使いこなそう〜^]
- https://t-wada.hatenablog.jp/entry/clean-code-that-works[動作するきれいなコード: SeleniumConf Tokyo 2019 基調講演文字起こし+α]

=== 参考図書

++++
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=k2works0c-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=4274217884&linkId=568f25b974af5645e862928a12c354e1&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"></iframe>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=k2works0c-22&language=ja_JP&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=4774193976&linkId=fee0d915272172c2e25393dd52537bdc"></iframe>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=k2works0c-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=427405019X&linkId=08e705a5969e20f5129b4d3cefbcdb15&bc1=000000&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"></iframe>
++++

[bibliography]
== References

- テスト駆動開発[[tdd]] Kent Beck (著), 和田 卓人 (翻訳):
  オーム社; 新訳版 (2017/10/14)
- プロを目指す人のためのRuby入門 言語仕様からテスト駆動開発・デバッグ技法まで (Software Design plusシリーズ)[[pruby]] 伊藤 淳一  (著):
  技術評論社 (2017/11/25)