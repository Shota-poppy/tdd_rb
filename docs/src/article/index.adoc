:toc: left
:toclevels: 5
:sectnums:

= テスト駆動開発から始めるRuby入門

これはとあるプログラマがどのような思考を経てテスト駆動開発でアプリケーションを構築していったかを解説した内容である。読者は隣りに座って話を聞きながらコードを追っかけているイメージで読み進めて言ってください。

== エピソード1
=== TODOリストから始めるテスト駆動開発
==== TODOリスト

アプリケーションを作成するにあたってまず何をすればよいだろうか？私は、まず仕様の確認をして *TODOリスト* を作るところから始めます。

[quote, '_テスト駆動開発_ <<tdd>>']
____
TODOリスト

何をテストすべきだろうか----着手する前に、必要になりそうなテストをリストに書き出しておこう。
____

仕様

  1 から 100 までの数をプリントするプログラムを書け。
  ただし 3 の倍数のときは数の代わりに｢Fizz｣と、5 の倍数のときは｢Buzz｣とプリントし、
  3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントすること。

仕様の内容をそのままプログラムに落とし込むには少しサイズが大きいようですね。なので最初の作業は仕様をTODOリストに分解する作業から着手することにしましょう。仕様をどのようにTODOに分解していくかは https://channel9.msdn.com/Events/de-code/2017/DO03?ocid=player[50 分でわかるテスト駆動開発^] の26分あたりを参考してください。


TODOリスト

* 数を文字列にして返す
* 3 の倍数のときは数の代わりに｢Fizz｣と返す
* 5 の倍数のときは｢Buzz｣と返す
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

まず *数を文字列にして返す* 作業に取り掛かりたいのですがまだプログラミング対象としてはサイズが大きいようですね。さらに具体的に分割しましょう。

* 数を文字列にして返す
** 1を渡したら文字列"1"を返す

よし、これならプログラムの対象として実装できそうだ。

=== テストファーストから始めるテスト駆動開発
==== テストファースト

最初にプログラムする対象を決めたので早速コードを実装・・・ではなく *テストファースト* で作業を進めていきましょう。まずはプログラムを実行するための準備作業を進める必要がありますね。

[quote, '_テスト駆動開発_ <<tdd>>']
____
テストファースト

いつテストを書くべきだろうか----それはテスト対象のコードを書く前だ。
____

では、どうやってテストすればいいでしょうか？テストフレームワークを使って自動テストを書きましょう。

[quote, '_テスト駆動開発_ <<tdd>>']
____
テスト（名詞）
どうやってソフトウェアをテストすればよいだろか----自動テストを書こう。
____

今回Rubyのテストフレームワークには http://docs.seattlerb.org/minitest/[Minitest] を利用します。Minitestの詳しい使い方に関しては _3.2 Minitestの基本_ <<pruby>>を参照してください。
では、まず以下の内容のテキストファイルを作成して `main.rb` で保存します。

[source, ruby]
----
require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'

class HelloTest < Minitest::Test
  def test_greeting
    assert_equal 'hello world', greeting
  end
end

def greeting
  'hello world'
end
----

テストを実行します。

[source, bash]
----
$ ruby main.rb
Started with run options --seed 9701

  1/1: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00090s
1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
----

テストは成功しましたね。では続いてテストを失敗させてみましょう。`hello world` を `hello world!!!` に書き換えてテストを実行してみるとどうなるでしょうか。

[source, ruby]
----
...
class HelloTest < Minitest::Test
  def test_greeting
    assert_equal 'hello world!!!', greeting
  end
end
...
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 18217

 FAIL["test_greeting", #<Minitest::Reporters::Suite:0x00007f98a59194f8 @name="HelloTest">, 0.0007280000027094502]
 test_greeting#HelloTest (0.00s)
        Expected: "hello world!!!"
          Actual: "hello world"
        main.rb:11:in `test_greeting'

  1/1: [======================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00101s
1 tests, 1 assertions, 1 failures, 0 errors, 0 skips
----

オッケー、テスティングフレームワークが正常に読み込まれて動作することが確認できました。続いてバージョン管理システムのセットアップをしておきましょう。なに、バージョン管理システム何それ？だって！？君はセーブしないでロールプレイングゲームをクリアできるのか？できないならまず https://backlog.com/ja/git-tutorial/intro/01/[ここ^] でGitを使ったバージョン管理の基本を学んでおきましょう。

[source, bash]
----
$ git init
$ git add .
$ git commit -m 'セットアップ'
----

これで https://t-wada.hatenablog.jp/entry/clean-code-that-works[ソフトウェア開発の三種の神器^]のうち *バージョン管理* と *テスティング* の準備が整いましたので *TODOリスト* の最初の作業に取り掛かかることができます。

=== アサートファーストから始めるテスト駆動開発

==== 仮実装

TODOリスト

* 数を文字列にして返す
** 1を渡したら文字列"1"を返す
* 3 の倍数のときは数の代わりに｢Fizz｣と返す
* 5 の倍数のときは｢Buzz｣と返す
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

*1を渡したら文字列"1"を返す* プログラムを `main.rb` に書きましょう。最初に何を書くのかって？ *アサートファースト* です。アサーションを最初に書きましょう。

[quote, '_テスト駆動開発_ <<tdd>>']
____
アサートファースト

いつアサーションを書くべきだろうか----最初に書こう

* システム構築はどこから始めるべきだろうか。システム構築が終わったらこうなる、というストーリーを語るところからだ。
* 機能はどこから書き始めるべきだろうか。コードが書き終わったらこのように動く、というテストを書くところからだ。
* ではテストはどこから書き始めるべきだろうか。それはテストの終わりにパスすべきアサーションを書くところからだ。
____

検証コードを書いて。

[source, ruby]
----
...
class FizzBuzzTest < Minitest::Test
  def test_1を渡したら文字列1を返す
    # 前準備
    # 実行
    # 検証
    assert_equal '1', FizzBuzz.generate(1)
  end
end
----

テストを実行します。

[source, bash]
----
$ ruby main.rb
Started with run options --seed 678

ERROR["test_1を渡したら文字列1を返す", #<Minitest::Reporters::Suite:0x00007f956d8b6870 @name="FizzBuzzTest">, 0.0006979999998293351]
 test_1を渡したら文字列1を返す#FizzBuzzTest (0.00s)
NameError:         NameError: uninitialized constant FizzBuzzTest::FizzBuzz
        Did you mean?  FizzBuzzTest
            main.rb:10:in `test_1を渡したら文字列1を返す'

  1/1: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00201s
1 tests, 0 assertions, 0 failures, 1 errors, 0 skips
----

`NameError:         NameError: uninitialized constant FizzBuzzTest::FizzBuzz` ...FizzBuzzが存在しない。そうですねまだ作ってないのだから当然ですよね。では `FizzBuzz.generate` メソッドを作りましょう。どんな振る舞いを書けばいいのでしょうか？とりあえず、最初のテストを通すため *仮実装* から始めるとしましょう。

[quote, '_テスト駆動開発_ <<tdd>>']
____
仮実装を経て本実装へ

失敗するテストを書いてから、最初に行う実装はどのようなものだろうか----ベタ書きの値を返そう。
____

[source, ruby]
----
...
class FizzBuzzTest < Minitest::Test
  def test_1を渡したら文字列1を返す
    # 前準備
    # 実行
    # 検証
    assert_equal '1', FizzBuzz.generate(1)
  end
end

class FizzBuzz
  def self.generate(n)
    '1'
  end
end
----

テストが通ることを確認します。

[source, bash]
----
$ ruby main.rb
Started with run options --seed 60122

  1/1: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00094s
1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
----

オッケー、これでTODOリストを片付けることができた。え？こんなベタ書きのプログラムでいいの？他に考えないといけないことたくさんあるんじゃない？ばかじゃないの？と思われるかもしませんが、この細かいステップに今しばらくお付き合いいただきたい。

TODOリスト

* 数を文字列にして返す
** [line-through]*1を渡したら文字列"1"を返す*
* 3 の倍数のときは数の代わりに｢Fizz｣と返す
* 5 の倍数のときは｢Buzz｣と返す
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

==== 三角測量

1を渡したら文字列1を返すようにできた。では、2を渡したらどうなるでしょうか。

TODOリスト

* 数を文字列にして返す
** [line-through]_1を渡したら文字列"1"を返す_
** *2を渡したら文字列"2"を返す*
* 3 の倍数のときは数の代わりに｢Fizz｣と返す
* 5 の倍数のときは｢Buzz｣と返す
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

[source, ruby]
----
...
class FizzBuzzTest < Minitest::Test
  def test_1を渡したら文字列1を返す
    # 前準備
    # 実行
    # 検証
    assert_equal '1', FizzBuzz.generate(1)
  end

  def test_2を渡したら文字列2を返す
    # 前準備
    # 実行
    # 検証
    assert_equal '2', FizzBuzz.generate(2)
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 62350

 FAIL["test_2を渡したら文字列2を返す", #<Minitest::Reporters::Suite:0x00007fa4968938d8 @name="FizzBuzzTest">, 0.0009390000013809185]
 test_2を渡したら文字列2を返す#FizzBuzzTest (0.00s)
        Expected: "2"
          Actual: "1"
        main.rb:17:in `test_2を渡したら文字列2を返す'

  2/2: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00179s
2 tests, 2 assertions, 1 failures, 0 errors, 0 skips
----

テストが失敗しました。それは文字列1しか返さないプログラムなのだから当然ですよね。では1が渡されたら文字列1を返し、2を渡したら文字列2を返すようにプログラムを修正しましょう。

[source, ruby]
----
...
class FizzBuzz
  def self.generate(n)
    n.to_s
  end
end
----

テストを実行します。

[source, bash]
----
$ ruby main.rb
Started with run options --seed 42479

  2/2: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00098s
2 tests, 2 assertions, 0 failures, 0 errors, 0 skips
----

テストが無事通りました。このように２つ目のテストによって `FizzBuzz.generate` メソッドの一般化を実現することができました。このようなアプローチを *三角測量* と言います。

[quote, '_テスト駆動開発_<<tdd>>']
____
三角測量

テストから最も慎重に一般化を引き出すやり方はどのようなものだろうか----２つ以上の例があるときだけ、一般化を行うようにしよう。
____

TODOリスト

* [line-through]*数を文字列にして返す*
** [line-through]_1を渡したら文字列"1"を返す_
** [line-through]_2を渡したら文字列"2"を返す_
* 3 の倍数のときは数の代わりに｢Fizz｣と返す
* 5 の倍数のときは｢Buzz｣と返す
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

たかが *数を文字列にして返す* プログラムを書くのにこんなに細かいステップを踏んでいくの？思ったかもしれません。プログラムを書くということは細かいステップを踏んで行くことなのです。そして、細かいステップを踏み続けることが大切なことなのです。ここでステップの区切りがいいところなので、バージョ管理システムにコミットしておきましょう。

[quote, '_テスト駆動開発_<<tdd>>']
____
TDDで大事なのは、細かいステップを踏むことではなく、細かいステップを踏み続けられるようになることだ。
____

[source, bash]
----
git commit -m 'test: 数を文字列にして返す'
----


=== リファクタリングから始めるテスト駆動開発
==== リファクタリング

ここでテスト駆動開発の流れを確認しておきましょう。

[quote, '_テスト駆動開発_<<tdd>>']
____
1. レッド：動作しない、おそらく最初のうちはコンパイルも通らないテストを１つ書く。
1. グリーン:そのテストを迅速に動作させる。このステップでは罪を犯してもよい。
1. リファクタリング:テストを通すために発生した重複をすべて除去する。

レッド・グリーン・リファクタリング。それがTDDのマントラだ。
____

コードはグリーンの状態ですが *リファクタリング* を実施していませんね。重複を除去しましょう。

テストコードを見てください。テストを実行するにあたって毎回前準備を実行する必要があります。こうした処理は往々にして同じ処理を実行するものなので *メソッドの抽出* を適用して重複を除去しましょう。

[source, ruby]
----
class FizzBuzzTest < Minitest::Test
  def test_1を渡したら文字列1を返す
    # 前準備
    # 実行
    # 検証
    assert_equal '1', FizzBuzz.generate(1)
  end

  def test_2を渡したら文字列2を返す
    # 前準備
    # 実行
    # 検証
    assert_equal '2', FizzBuzz.generate(2)
  end
end
----

テストフレームワークでは前処理にあたる部分を実行する機能がサポートされています。Minitestでは `setup` メソッドがそれに当たるので `FizzBuzz` オブジェクトを共有して共通利用できるようにしてみましょう。

[source, ruby]
----
class FizzBuzzTest < Minitest::Test
  def setup
    @fizzbuzz = FizzBuzz
  end

  def test_1を渡したら文字列1を返す
    assert_equal '1', @fizzbuzz.generate(1)
  end

  def test_2を渡したら文字列2を返す
    assert_equal '2', @fizzbuzz.generate(2)
  end
end
----

テストプログラムを変更してしまいましたが壊れていないでしょうか？確認するにはどうすればいいでしょう？
テストを実行して確認すればいいですよね。

[source, bash]
----
$ ruby main.rb
Started with run options --seed 33356

  2/2: [======================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00083s
2 tests, 2 assertions, 0 failures, 0 errors, 0 skips
----

オッケー、前回コミットした時と同じグリーンの状態のままですよね。区切りが良いのでここでコミットしておきましょう。

[source, bash]
----
git commit -m 'refactor: メソッドの抽出'
----


もう一つ気になるところがあります。

[source, ruby]
----
...
class FizzBuzz
  def self.generate(n)
    n.to_s
  end
end
----

引数の名前が `n` ですね。コンピュータにはわかるかもしれませんが人間が読むコードとして少し不親切です。特にRubyのような動的言語では型が明確に定義されないのでなおさらです。ここは *変数名の変更* を適用して人間にとって読みやすいコードにリファクタリングしましょう。

[source, ruby]
----
...
class FizzBuzz
  def self.generate(number)
    number.to_s
  end
end
----

続いて、変更で壊れていないかを確認します。

[source, bash]
----
$ ruby main.rb
Started with run options --seed 33356

  2/2: [======================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00083s
2 tests, 2 assertions, 0 failures, 0 errors, 0 skips
----


オッケー、この時点でテストコードとプロダクトコードを変更しましたがその変更はすでに作成した自動テストによって壊れていないことを簡単に確認することができました。え、こんな簡単な変更でプログラムが壊れるわけないじゃん。ですって。残念ながら私は絶対ミスしない完璧な人間ではないし、どちらかといえばおっちょこちょいなプログラマなのでこんな間違いも普通にやらかします。

[source, ruby]
----
...
class FizzBuzz
  def self.generate(number)
    numbr.to_s
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 59453

ERROR["test_1を渡したら文字列1を返す", #<Minitest::Reporters::Suite:0x0000564f6b1dfc70 @name="FizzBuzzTest">, 0.001019135997921694]
 test_1を渡したら文字列1を返す#FizzBuzzTest (0.00s)
NameError:         NameError: undefined local variable or method `numbr' for FizzBuzz:Class
        Did you mean?  number
            main.rb:21:in `generate'
            main.rb:11:in `test_1を渡したら文字列1を返す'

ERROR["test_2を渡したら文字列2を返す", #<Minitest::Reporters::Suite:0x0000564f6b1985f0 @name="FizzBuzzTest">, 0.003952859999117209]
 test_2を渡したら文字列2を返す#FizzBuzzTest (0.00s)
NameError:         NameError: undefined local variable or method `numbr' for FizzBuzz:Class
        Did you mean?  number
            main.rb:21:in `generate'
            main.rb:15:in `test_2を渡したら文字列2を返す'

  2/2: [====================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00746s
2 tests, 0 assertions, 0 failures, 2 errors, 0 skips
----

そんなドジっ子プログラマでも自動テストと小さなステップのおかげで上記のようなしょうもない間違いもすぐに見つけてすぐに対応することができるのでコードを変更する勇気を持つことができるのです。


[quote, '_テスト駆動開発_<<tdd>>']
____
テスト駆動開発は、プログラミング中の不安をコントロールする手法だ。
____

このグリーンの状態にいつでも戻れるようにコミットして次の *TODOリスト* の内容に取り掛かるとしましょう。

[source, bash]
----
git commit -m 'refactor: 変数名の変更'
----

==== 明白な実装

次は *3を渡したら文字列"Fizz"* を返すプログラムに取り組むとしましょう。

TODOリスト

* [line-through]_数を文字列にして返す_
** [line-through]_1を渡したら文字列"1"を返す_
** [line-through]_2を渡したら文字列"2"を返す_
* 3 の倍数のときは数の代わりに｢Fizz｣と返す
** *3を渡したら文字列"Fizz"を返す*
* 5 の倍数のときは｢Buzz｣と返す
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

まずは、*テストファースト* *アサートファースト* で小さなステップで進めていくんでしたよね。

[source, ruby]
----
....
  def test_3を渡したら文字列Fizzを返す
    assert_equal 'Fizz', @fizzbuzz.generate(3)
  end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 7095

 FAIL["test_3を渡したら文字列Fizzを返す", #<Minitest::Reporters::Suite:0x00007fbadf865f50 @name="FizzBuzzTest">, 0.017029999995429534]
 test_3を渡したら文字列Fizzを返す#FizzBuzzTest (0.02s)
        --- expected
        +++ actual
        @@ -1 +1,3 @@
        -"Fizz"
        +# encoding: US-ASCII
        +#    valid: true
        +"3"
        main.rb:19:in `test_3を渡したら文字列Fizzを返す'

  3/3: [======================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.05129s
3 tests, 3 assertions, 1 failures, 0 errors, 0 skips
----

さて、失敗するテストを書いたので次はテストを通すためのプロダクトコードを書くわけだがどうしましょうか？　*仮実装*　でベタなコードを書きますか？実現したい振る舞いは `もし3を渡したらならば文字列Fizzを返す` です。英語なら `If 3 then result is Fizz` といったところでしょうか。ここは *明白な実装* で片付けた方が早いでしょう。

[quote, '_テスト駆動開発_<<tdd>>']
____
明白な実装

シンプルな操作を実現するにはどうすればいいだろうか----そのまま実装しよう。

仮実装や三角測量は、細かく細かく刻んだ小さなステップだ。だが、ときには実装をどうすべきか既に見えていることが。
そのまま進もう。例えば先ほどのplusメソッドくらいシンプルなものを仮実装する必要が本当にあるだろうか。
普通は、その必要はない。頭に浮かんだ明白な実装をただ単にコードに落とすだけだ。もしもレッドバーが出て驚いたら、あらためてもう少し歩幅を小さくしよう。
____

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    number.to_s
  end
end
----

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number % 3 == 0
       result = 'Fizz'
    end
    result
  end
end
----

テストがグリーンになったのでコミットしておきます。
[source, bash]
----
$ ruby main.rb
$ git commit -m 'test: 3を渡したら文字列Buzzを返す'
----

TODOリスト

* [line-through]_数を文字列にして返す_
** [line-through]_1を渡したら文字列"1"を返す_
** [line-through]*2を渡したら文字列"2"を返す*
* [line-through]_3 の倍数のときは数の代わりに｢Fizz｣と返す_
** [line-through]_3を渡したら文字列"Fizz"を返す_
* 5 の倍数のときは｢Buzz｣と返す
** 5を渡したら文字列"Buzz"を返す
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number % 3 == 0
       result = 'Fizz'
    end
    result
  end
end
----

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero? == 0
       result = 'Fizz'
    end
    result
  end
end
----

ここでは *アルゴリズムの置き換え* を適用してよりRubyらしい書き方にリファクタリングしてみました。

[source, bash]
----
$ ruby main.rb
$ git commit -m 'refactor: アルゴリズムの置き換え'
----

だんだんとリズムに乗ってきましたここはギアを上げて *明白な実装* で引き続き *TODOリスト* の内容を片付けていきましょう。

TODOリスト

* [line-through]_数を文字列にして返す_
** [line-through]_1を渡したら文字列"1"を返す_
** [line-through]_2を渡したら文字列"2"を返す_
* [line-through]_3の倍数のときは数の代わりに｢Fizz｣と返す_
** [line-through]_3を渡したら文字列"Fizz"を返す_
* 5 の倍数のときは｢Buzz｣と返す
** *5を渡したら文字列"Buzz"を返す*
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

[source, ruby]
----
...
  def test_5を渡したら文字列Buzzを返す
    assert_equal 'Buzz', @fizzbuzz.generate(5)
  end
end
----

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    result = 'Fizz' if number % 3 == 0
    result
  end
end
----

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero?
      result = 'Fizz'
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end
    result
  end
end
----

[source, bash]
----
$ ruby main.rb
$ git commit -m 'test: 5を渡したら文字列Buzzを返す'
----

TODOリスト

* [line-through]_数を文字列にして返す_
** [line-through]_1を渡したら文字列"1"を返す_
** [line-through]_2を渡したら文字列"2"を返す_
* [line-through]_3の倍数のときは数の代わりに｢Fizz｣と返す_
** [line-through]_3を渡したら文字列"Fizz"を返す_
* 5 の倍数のときは｢Buzz｣と返す
** [line-through]*5を渡したら文字列"Buzz"を返す*
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
* 1 から 100 までの数
* プリントする

[source, ruby]
----
class FizzBuzzTest < Minitest::Test
  def setup
    @fizzbuzz = FizzBuzz
  end

  def test_1を渡したら文字列1を返す
    assert_equal '1', @fizzbuzz.generate(1)
  end

  def test_2を渡したら文字列2を返す
    assert_equal '2', @fizzbuzz.generate(2)
  end

  def test_3を渡したら文字列Fizzを返す
    assert_equal 'Fizz', @fizzbuzz.generate(3)
  end

  def test_5を渡したら文字列Buzzを返す
    assert_equal 'Buzz', @fizzbuzz.generate(5)
  end
end
----

[source, ruby]
----
class FizzBuzzTest < Minitest::Test
  describe 'FizzBuzz' do
    def setup
      @fizzbuzz = FizzBuzz
    end

    describe '三の倍数の場合' do
      def test_3を渡したら文字列Fizzを返す
        assert_equal 'Fizz', @fizzbuzz.generate(3)
      end
    end

    describe '五の倍数の場合' do
      def test_5を渡したら文字列Buzzを返す
        assert_equal 'Buzz', @fizzbuzz.generate(5)
      end
    end

    describe 'その他の場合' do
      def test_1を渡したら文字列1を返す
        assert_equal '1', @fizzbuzz.generate(1)
      end

      def test_2を渡したら文字列2を返す
        assert_equal '2', @fizzbuzz.generate(2)
      end
    end
  end
end
----

[source, ruby]
----
$ ruby main.rb
$ git commit -m 'refactor: メソッドのインライン化'
----

ここでは、*メソッドのインライン化* を適用してしてテストコードを読みやすくすることにしました。自己文書化により動作する仕様書にすることができました。

さあ、*TODOリスト* もだいぶ消化されてきましたね。もうひと踏ん張りです。

TODOリスト

* [line-through]_数を文字列にして返す_
** [line-through]_1を渡したら文字列"1"を返す_
** [line-through]_2を渡したら文字列"2"を返す_
* [line-through]_3の倍数のときは数の代わりに｢Fizz｣と返す_
** [line-through]_3を渡したら文字列"Fizz"を返す_
* [line-through]_5 の倍数のときは｢Buzz｣と返す_
** [line-through]_5を渡したら文字列"Buzz"を返す_
* 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
** *15を渡したら文字列FizzBuzzを返す*
* 1 から 100 までの数
* プリントする

[source, ruby]
----
...
    describe '三と五の倍数の場合' do
      def test_15を渡したら文字列FizzBuzzを返す
        assert_equal 'FizzBuzz', @fizzbuzz.generate(15)
      end
    end
...
----

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero?
      result = 'Fizz'
    elsif number.modulo(5).zero?
      result = 'Buzz'
    elsif number.modulo(15).zero?
      result = 'FizzBuzz'
    end
    result
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 45982

 FAIL["test_15を渡したら文字列FizzBuzzを返す", #<Minitest::Reporters::Suite:0x00007f822c00b2b0 @name="FizzBuzz::三と五の倍数の場合">, 0.00231200000
0529224]
 test_15を渡したら文字列FizzBuzzを返す#FizzBuzz::三と五の倍数の場合 (0.00s)
        Expected: "FizzBuzz"
          Actual: "Fizz"
        main.rb:25:in `test_15を渡したら文字列FizzBuzzを返す'

  4/4: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00964s
4 tests, 4 assertions, 1 failures, 0 errors, 0 skips
----

Byebugをインストールする

[source, bash]
----
$ gem install byebug
----

Bybugからプログラムを起動する

[source, bash]
----
$ byebug main.rb

[1, 10] in /Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/main.rb
=>  1: require 'minitest/reporters'
    2: Minitest::Reporters.use!
    3: require 'minitest/autorun'
    4:
    5: class FizzBuzzTest < Minitest::Test
    6:   describe 'FizzBuzz' do
    7:     def setup
    8:       @fizzbuzz = FizzBuzz
    9:     end
   10:
(byebug)
----

詳しい操作に関しては https://qiita.com/jnchito/items/5aaf323ab4f24b526a61[printデバッグにさようなら！Ruby初心者のためのByebugチュートリアル^] を参照

byebugメソッドでコード内にブレークポイントを埋め込む

[source, ruby]
----
...
    describe '三と五の倍数の場合' do
      def test_15を渡したら文字列FizzBuzzを返す
        require 'byebug'
        byebug
        assert_equal 'FizzBuzz', @fizzbuzz.generate(15)
      end
    end
...
----

[source, bash]
----
$ byebug main.rb

[1, 10] in /Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/main.rb
=>  1: require 'minitest/reporters'
    2: Minitest::Reporters.use!
    3: require 'minitest/autorun'
    4:
    5: class FizzBuzzTest < Minitest::Test
    6:   describe 'FizzBuzz' do
    7:     def setup
    8:       @fizzbuzz = FizzBuzz
    9:     end
   10:
(byebug) c
   22:
   23:     describe '三と五の倍数の場合' do
   24:       def test_15を渡したら文字列FizzBuzzを返す
   25:         require 'byebug'
   26:         byebug
=> 27:         assert_equal 'FizzBuzz', @fizzbuzz.generate(15)
   28:       end
   29:     end
   30:
   31:     describe 'その他の場合' do
(byebug) s
   36:   end
   37: end
   38:
   39: class FizzBuzz
   40:   def self.generate(number)
=> 41:     result = number.to_s
   42:     if number.modulo(3).zero?
   43:       result = 'Fizz'
   44:     elsif number.modulo(5).zero?
   45:       result = 'Buzz'
(byebug) s
   37: end
   38:
   39: class FizzBuzz
   40:   def self.generate(number)
   41:     result = number.to_s
=> 42:     if number.modulo(3).zero?
   43:       result = 'Fizz'
   44:     elsif number.modulo(5).zero?
   45:       result = 'Buzz'
   46:     elsif number.modulo(15).zero?
(byebug)
   38:
   39: class FizzBuzz
   40:   def self.generate(number)
   41:     result = number.to_s
   42:     if number.modulo(3).zero?
=> 43:       result = 'Fizz'
   44:     elsif number.modulo(5).zero?
   45:       result = 'Buzz'
   46:     elsif number.modulo(15).zero?
   47:       result = 'FizzBuzz'
(byebug) result
"15"
(byebug) q!
----

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero?
      result = 'Fizz'
      if number.modulo(15).zero?
        result = 'FizzBuzz'
      end
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end
    result
  end
end
----

[source, bash]
----
$ ruby main.rb
$ git commit -m 'test: 15を渡したら文字列FizzBuzzを返す'
----


レッド・グリーン・リファクター

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero? && number.modulo(5).zero?
      result = 'FizzBuzz'
    elsif number.modulo(3).zero?
      result = 'Fizz'
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end
    result
  end
end
----

[source, bash]
----
$ ruby main.rb
$ git commit -m 'refactor: アルゴリズムの置き換え:'
----

==== 1から100までの数を返す

TODOリスト

- [x] 3 の倍数のときは数の代わりに｢Fizz｣と返す
 - [x] 3を渡したら文字列"Fizz"を返す
- [x] 5 の倍数のときは｢Buzz｣と返す
 - [x] 5を渡したら文字列"Buzz"を返す
- [ ] 1から100までの数を返す
 - [ ] はじめは文字列1を返す
 - [ ] 最後は文字列100を返す

[source, ruby]
----
...
    describe '1から100までの数を返す' do
      def setup
        @result = FizzBuzz.print_1_to_100
      end

      def test_はじめは文字列1を返す
        assert_equal '1', @result.first
      end

      def test_最後は文字列100を返す
        assert_equal '100', @result.last
      end
    end
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 39661

ERROR["test_はじめは文字列1を返す", #<Minitest::Reporters::Suite:0x00007fef0502c910 @name="FizzBuzz::1から100までの数を返す">, 0.0026019999995696708]
 test_はじめは文字列1を返す#FizzBuzz::1から100までの数を返す (0.00s)
NoMethodError:         NoMethodError: undefined method `print_1_to_100' for FizzBuzz:Class
            main.rb:37:in `setup'

ERROR["test_最後は文字列100を返す", #<Minitest::Reporters::Suite:0x00007fef248b4cd0 @name="FizzBuzz::1から100までの数を返す">, 0.004527000000052794]
 test_最後は文字列100を返す#FizzBuzz::1から100までの数を返す (0.00s)
NoMethodError:         NoMethodError: undefined method `print_1_to_100' for FizzBuzz:Class
            main.rb:37:in `setup'

  6/6: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.02732s
6 tests, 4 assertions, 0 failures, 2 errors, 0 skips
----

仮実装

[source, ruby]
----
...:
  def self.print_1_to_100
    [1, 100]
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 16600

 FAIL["test_はじめは文字列1を返す", #<Minitest::Reporters::Suite:0x00007fe780062588 @name="FizzBuzz::1から100までの数を返す">, 0.002943999999843072]
 test_はじめは文字列1を返す#FizzBuzz::1から100までの数を返す (0.00s)
        Expected: "1"
          Actual: 1
        main.rb:41:in `test_はじめは文字列1を返す'

 FAIL["test_最後は文字列100を返す", #<Minitest::Reporters::Suite:0x00007fe780060080 @name="FizzBuzz::1から100までの数を返す">, 0.0032649999993736856]
 test_最後は文字列100を返す#FizzBuzz::1から100までの数を返す (0.00s)
        Expected: "100"
          Actual: 100
        main.rb:45:in `test_最後は文字列100を返す'

  6/6: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.04183s
6 tests, 6 assertions, 2 failures, 0 errors, 0 skips
----

[source, ruby]
----
...
  def self.print_1_to_100
    %w[1 100]
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 9

  6/6: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.03464s
6 tests, 6 assertions, 0 failures, 0 errors, 0 skips
----

[source, ruby]
----
...
  def self.print_1_to_100
    result = []

    (1..100).each do |i|
      result.push(i)
    end

    result
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 15628

 FAIL["test_はじめは文字列1を返す", #<Minitest::Reporters::Suite:0x00007fc1ac161ac8 @name="FizzBuzz::1から100までの数を返す">, 0.0013429999999061693]
 test_はじめは文字列1を返す#FizzBuzz::1から100までの数を返す (0.00s)
        Expected: "1"
          Actual: 1
        main.rb:41:in `test_はじめは文字列1を返す'

 FAIL["test_最後は文字列100を返す", #<Minitest::Reporters::Suite:0x00007fc1ac08a8e8 @name="FizzBuzz::1から100までの数を返す">, 0.0015599999987898627]
 test_最後は文字列100を返す#FizzBuzz::1から100までの数を返す (0.00s)
        Expected: "100"
          Actual: 100
        main.rb:45:in `test_最後は文字列100を返す'

  6/6: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.02641s
6 tests, 6 assertions, 2 failures, 0 errors, 0 skips
----

[source, ruby]
----
...
  def self.print_1_to_100
    result = []

    (1..100).each do |i|
      result.push(i.to_s)
    end

    result
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 54888

  6/6: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00289s
6 tests, 6 assertions, 0 failures, 0 errors, 0 skips
----

[source, bash]
----
...
  def self.print_1_to_100
    result = []

    (1..100).each { |i| result.push(i.to_s) }

    result
  end
end
----

TODOリスト

- [ ] 1から100までの数を返す
 - [x] はじめは文字列1を返す
 - [x] 最後は文字列100を返す
 - [ ] 2番めは文字列Fizzを返す

[source, ruby]
----
...
      def test_2番目は文字列Fizzを返す
        assert_equal 'Fizz', @result[2]
      end
    end
  end
end
----


[source, bash]
----
$ ruby main.rb
Started with run options --seed 44380

 FAIL["test_2番目は文字列Fizzを返す", #<Minitest::Reporters::Suite:0x00007fb3950f8688 @name="FizzBuzz::1から100までの数を返す">, 0.01583800000116753]
 test_2番目は文字列Fizzを返す#FizzBuzz::1から100までの数を返す (0.02s)
        --- expected
        +++ actual
        @@ -1 +1,3 @@
        -"Fizz"
        +# encoding: US-ASCII
        +#    valid: true
        +"3"
        main.rb:49:in `test_2番目は文字列Fizzを返す'

  7/7: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.02959s
7 tests, 7 assertions, 1 failures, 0 errors, 0 skips
----

[source, ruby]
----
...
  def self.print_1_to_100
    result = []

    (1..100).each { |i| result.push(generate(i)) }

    result
  end
end
----

[source, bash]
----
 ruby main.rb
Started with run options --seed 16609

 FAIL["test_最後は文字列100を返す", #<Minitest::Reporters::Suite:0x00007f833002af20 @name="FizzBuzz::1から100までの数を返す">, 0.0017719999996188562]
 test_最後は文字列100を返す#FizzBuzz::1から100までの数を返す (0.00s)
        Expected: "100"
          Actual: "Buzz"
        main.rb:45:in `test_最後は文字列100を返す'

  7/7: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00691s
7 tests, 7 assertions, 1 failures, 0 errors, 0 skips
----

[source, ruby]
----
...
      def test_最後は文字列Buzzを返す
        assert_equal 'Buzz', @result.last
      end

      def test_2番目は文字列Fizzを返す
        assert_equal 'Fizz', @result[2]
      end
    end
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 1245

  7/7: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.02442s
7 tests, 7 assertions, 0 failures, 0 errors, 0 skips
----


TODOリスト

- [ ] 1から100までの数を返す
 - [x] はじめは文字列1を返す
 - [x] 最後は文字列100を返す
 - [x] 2番めは文字列Fizzを返す
 - [ ] 4番目は文字列Buzzを返す
 - [ ] 14番目は文字列FizzBuzzを返す

[source, ruby]
----
...
      def test_2番目は文字列Fizzを返す
        assert_equal 'Fizz', @result[2]
      end

      def test_4番目は文字列Buzzを返す
        assert_equal 'Buzz', @result[4]
      end
    end
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 18567

  8/8: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.03529s
8 tests, 8 assertions, 0 failures, 0 errors, 0 skips
----

[source, ruby]
----
...
      def test_2番目は文字列Fizzを返す
        assert_equal 'Fizz', @result[2]
      end

      def test_4番目は文字列Buzzを返す
        assert_equal 'Buzz', @result[4]
      end

      def test_14番目は文字列FizzBuzzを返す
        assert_equal 'FizzBuzz', @result[14]
      end
    end
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 61724

  9/9: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.05912s
9 tests, 9 assertions, 0 failures, 0 errors, 0 skips
----

[source, bash]
----
$ ruby main.rb
$ git commit -m 'test: 1から100までの数を返す'
----

TODOリスト

- [x] 1から100までの数を返す
 - [x] はじめは文字列1を返す
 - [x] 最後は文字列100を返す
 - [x] 2番めは文字列Fizzを返す
 - [x] 4番目は文字列Buzzを返す
 - [x] 14番目は文字列FizzBuzzを返す

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s

    if number.modulo(3).zero? && number.modulo(5).zero?
      result = 'FizzBuzz'
    elsif number.modulo(3).zero?
      result = 'Fizz'
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end

    result
  end
...:
----

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s

    return 'FizzBuzz' if number.modulo(3).zero? && number.modulo(5).zero?
    return 'Fizz' if number.modulo(3).zero?
    return 'Buzz' if number.modulo(5).zero?

    result
  end
...
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 24552

  9/9: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.04318s
9 tests, 9 assertions, 0 failures, 0 errors, 0 skips
----

[source, bash]
----
$ git commit -m 'refactor: ガード節による入れ子条件の置き換え'
----


[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    result = number.to_s

    return 'FizzBuzz' if number.modulo(3).zero? && number.modulo(5).zero?
    return 'Fizz' if number.modulo(3).zero?
    return 'Buzz' if number.modulo(5).zero?

    result
  end
...
----

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    return 'FizzBuzz' if number.modulo(3).zero? && number.modulo(5).zero?
    return 'Fizz' if number.modulo(3).zero?
    return 'Buzz' if number.modulo(5).zero?
    number.to_s
  end
...
----

[source, bash]
----
$ ruby main.rb
$ git commit -m 'refactor:　変数のインライン化'
----

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    return 'FizzBuzz' if number.modulo(3).zero? && number.modulo(5).zero?
    return 'Fizz' if number.modulo(3).zero?
    return 'Buzz' if number.modulo(5).zero?
    number.to_s
  end
...
----

[source, ruby]
----
class FizzBuzz
  def self.generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz && is_buzz
    return 'Fizz' if is_fizz
    return 'Buzz' if is_buzz
    number.to_s
  end
...
----

[source, bash]
----
$ ruby main.rb
$ git commit -m 'refactor:　変数の抽出'
----

[source, ruby]
----
class FizzBuzz
...
  def self.print_1_to_100
    result = []

    (1..100).each { |i| result.push(generate(i)) }

    result
  end
end
----

[source, ruby]
----
class FizzBuzz
...
  def self.generate_list
    result = []

    (1..100).each { |i| result.push(generate(i)) }

    result
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 23868

ERROR["test_14番目は文字列FizzBuzzを返す", #<Minitest::Reporters::Suite:0x00007ff0d918a368 @name="FizzBuzz::1から100までの数を返す">, 0.0013330000001587905]
 test_14番目は文字列FizzBuzzを返す#FizzBuzz::1から100までの数を返す (0.00s)
NoMethodError:         NoMethodError: undefined method `print_1_to_100' for FizzBuzz:Class
            main.rb:37:in `setup'

ERROR["test_4番目は文字列Buzzを返す", #<Minitest::Reporters::Suite:0x00007ff0d985dd48 @name="FizzBuzz::1から100までの数を返す">, 0.003452000000834232]
 test_4番目は文字列Buzzを返す#FizzBuzz::1から100までの数を返す (0.00s)
NoMethodError:         NoMethodError: undefined method `print_1_to_100' for FizzBuzz:Class
            main.rb:37:in `setup'

ERROR["test_はじめは文字列1を返す", #<Minitest::Reporters::Suite:0x00007ff0d91914b0 @name="FizzBuzz::1から100までの数を返す">, 0.006145000001197332]
 test_はじめは文字列1を返す#FizzBuzz::1から100までの数を返す (0.01s)
NoMethodError:         NoMethodError: undefined method `print_1_to_100' for FizzBuzz:Class
            main.rb:37:in `setup'

ERROR["test_2番目は文字列Fizzを返す", #<Minitest::Reporters::Suite:0x00007ff0da87dca0 @name="FizzBuzz::1から100までの数を返す">, 0.008593000000473694]
 test_2番目は文字列Fizzを返す#FizzBuzz::1から100までの数を返す (0.01s)
NoMethodError:         NoMethodError: undefined method `print_1_to_100' for FizzBuzz:Class
            main.rb:37:in `setup'

ERROR["test_最後は文字列Buzzを返す", #<Minitest::Reporters::Suite:0x00007ff0da8597d8 @name="FizzBuzz::1から100までの数を返す">, 0.045028000000456814]
 test_最後は文字列Buzzを返す#FizzBuzz::1から100までの数を返す (0.05s)
NoMethodError:         NoMethodError: undefined method `print_1_to_100' for FizzBuzz:Class
            main.rb:37:in `setup'

  9/9: [======================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.04876s
9 tests, 4 assertions, 0 failures, 5 errors, 0 skips
----

[source, ruby]
----
class FizzBuzzTest < Minitest::Test
...
    describe '1から100までの数を返す' do
      def setup
        @result = FizzBuzz.generate_list
      end
...
----

[source, bash]
----
$ ruby main.rb
$ git commit -m 'refactor:　メソッド名の変更'
----

[source, ruby]
----
class FizzBuzz
...
  def self.generate_list
    (1..100).each { |i| result.push(generate(i)) }
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 28039

ERROR["test_14番目は文字列FizzBuzzを返す", #<Minitest::Reporters::Suite:0x00007f85a88b5670 @name="FizzBuzz::1から100までの数を返す">, 0.001374999999825377]
 test_14番目は文字列FizzBuzzを返す#FizzBuzz::1から100までの数を返す (0.00s)
NameError:         NameError: undefined local variable or method `result' for FizzBuzz:Class
            main.rb:75:in `block in generate_list'
            main.rb:75:in `each'
            main.rb:75:in `generate_list'
            main.rb:37:in `setup'

ERROR["test_4番目は文字列Buzzを返す", #<Minitest::Reporters::Suite:0x00007f85a88c70f0 @name="FizzBuzz::1から100までの数を返す">, 0.002824999999575084]
 test_4番目は文字列Buzzを返す#FizzBuzz::1から100までの数を返す (0.00s)
NameError:         NameError: undefined local variable or method `result' for FizzBuzz:Class
            main.rb:75:in `block in generate_list'
            main.rb:75:in `each'
            main.rb:75:in `generate_list'
            main.rb:37:in `setup'

ERROR["test_2番目は文字列Fizzを返す", #<Minitest::Reporters::Suite:0x00007f859f070540 @name="FizzBuzz::1から100までの数を返す">, 0.0041270000001532026]
 test_2番目は文字列Fizzを返す#FizzBuzz::1から100までの数を返す (0.00s)
NameError:         NameError: undefined local variable or method `result' for FizzBuzz:Class
            main.rb:75:in `block in generate_list'
            main.rb:75:in `each'
            main.rb:75:in `generate_list'
            main.rb:37:in `setup'

ERROR["test_はじめは文字列1を返す", #<Minitest::Reporters::Suite:0x00007f856f804638 @name="FizzBuzz::1から100までの数を返す">, 0.03712699999960023]
 test_はじめは文字列1を返す#FizzBuzz::1から100までの数を返す (0.04s)
NameError:         NameError: undefined local variable or method `result' for FizzBuzz:Class
            main.rb:75:in `block in generate_list'
            main.rb:75:in `each'
            main.rb:75:in `generate_list'
            main.rb:37:in `setup'

ERROR["test_最後は文字列Buzzを返す", #<Minitest::Reporters::Suite:0x00007f856e8046e8 @name="FizzBuzz::1から100までの数を返す">, 0.0393739999999525]
 test_最後は文字列Buzzを返す#FizzBuzz::1から100までの数を返す (0.04s)
NameError:         NameError: undefined local variable or method `result' for FizzBuzz:Class
            main.rb:75:in `block in generate_list'
            main.rb:75:in `each'
            main.rb:75:in `generate_list'
            main.rb:37:in `setup'

  9/9: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.04360s
9 tests, 4 assertions, 0 failures, 5 errors, 0 skips
----

[source, ruby]
----
class FizzBuzz
...
  def self.generate_list
    (1..100).each { |i| generate(i) }
  end
end
----


[source, bash]
----
$ ruby main.rb
Started with run options --seed 13473

 FAIL["test_最後は文字列Buzzを返す", #<Minitest::Reporters::Suite:0x00007fbbc50574d0 @name="FizzBuzz::1から100までの数を返す">, 0.0016329999998561107]
 test_最後は文字列Buzzを返す#FizzBuzz::1から100までの数を返す (0.00s)
        Expected: "Buzz"
          Actual: 100
        main.rb:45:in `test_最後は文字列Buzzを返す'

ERROR["test_14番目は文字列FizzBuzzを返す", #<Minitest::Reporters::Suite:0x00007fbbc50a6a80 @name="FizzBuzz::1から100までの数を返す">, 0.001825999999709893]
 test_14番目は文字列FizzBuzzを返す#FizzBuzz::1から100までの数を返す (0.00s)
NoMethodError:         NoMethodError: undefined method `[]' for 1..100:Range
            main.rb:57:in `test_14番目は文字列FizzBuzzを返す'

 FAIL["test_はじめは文字列1を返す", #<Minitest::Reporters::Suite:0x00007fbbc50ad330 @name="FizzBuzz::1から100までの数を返す">, 0.002407999998467858]
 test_はじめは文字列1を返す#FizzBuzz::1から100までの数を返す (0.00s)
        Expected: "1"
          Actual: 1
        main.rb:41:in `test_はじめは文字列1を返す'

ERROR["test_2番目は文字列Fizzを返す", #<Minitest::Reporters::Suite:0x00007fbba5016c20 @name="FizzBuzz::1から100までの数を返す">, 0.02718299999833107]
 test_2番目は文字列Fizzを返す#FizzBuzz::1から100までの数を返す (0.03s)
NoMethodError:         NoMethodError: undefined method `[]' for 1..100:Range
            main.rb:49:in `test_2番目は文字列Fizzを返す'

ERROR["test_4番目は文字列Buzzを返す", #<Minitest::Reporters::Suite:0x00007fbba502dbc8 @name="FizzBuzz::1から100までの数を返す">, 0.027986999999484397]
 test_4番目は文字列Buzzを返す#FizzBuzz::1から100までの数を返す (0.03s)
NoMethodError:         NoMethodError: undefined method `[]' for 1..100:Range
            main.rb:53:in `test_4番目は文字列Buzzを返す'

  9/9: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.02914s
9 tests, 6 assertions, 2 failures, 3 errors, 0 skips
----


[source, ruby]
----
class FizzBuzz
...
  def self.generate_list
    (1..100).each { |i| generate(i) }
  end
end
----

[source, bash]
----
$ ruby main.rb
Started with run options --seed 27662

  9/9: [======================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00221s
9 tests, 9 assertions, 0 failures, 0 errors, 0 skips
----

[source, bash]
----
$ git commit -m 'refactor: パイプラインによるループの置き換え'
----

学習用テスト

[source, ruby]
----
  describe '配列や繰り返し処理を理解する' do
    def test_繰り返し処理
      $stdout = StringIO.new
      [1, 2, 3].each { |i| p i * i }
      output = $stdout.string

      assert_equal "1\n" + "4\n" + "9\n", output
    end

    def test_特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].select(&:integer?)
      assert_equal [2, 4], result
    end

    def test_特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].find_all(&:integer?)
      assert_equal [2, 4], result
    end

    def test_特定の条件を満たさない要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].reject(&:integer?)
      assert_equal [1.1, 3.3], result
    end

    def test_新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].map(&:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].collect(&:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].find(&:size)
      assert_equal 'apple', result
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].detect(&:size)
      assert_equal 'apple', result
    end

    def test_指定した評価式で並び変えた配列を返す
      assert_equal %w[1 10 13 2 3 4], %w[2 4 13 3 1 10].sort
      assert_equal %w[1 2 3 4 10 13],
                   %w[2 4 13 3 1 10].sort { |a, b| a.to_i <=> b.to_i }
      assert_equal %w[13 10 4 3 2 1],
                   %w[2 4 13 3 1 10].sort { |b, a| a.to_i <=> b.to_i }
    end

    def test_配列の中から、条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry apricot].grep(/^a/)
      assert_equal %w[apple apricot], result
    end

    def test_ブロック内の条件式が真である間までの要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9].take_while { |item| item < 6 }
      assert_equal [1, 2, 3, 4, 5], result
    end

    def test_ブロック内の条件式が真である以降の要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].drop_while { |item| item < 6 }
      assert_equal [6, 7, 8, 9, 10], result
    end

    def test_畳み込み演算を行う
      result = [1, 2, 3, 4, 5].inject(0) { |total, n| total + n }
      assert_equal 15, result
    end

    def test_畳み込み演算を行う
      result = [1, 2, 3, 4, 5].reduce { |total, n| total + n }
      assert_equal 15, result
    end
  end
----

[source, bash]
----
$ git commit -m 'test: 学習用テスト'
----

[source, ruby]
----
class FizzBuzz
...
  def self.generate_list
    (1..100).each { |i| generate(i) }
  end
end
----

[source, ruby]
----
class FizzBuzz
  MAX_NUMBER = 100
...
  def self.generate_list
    (1..MAX_NUMBER).map { |i| generate(i) }
  end
end
----

[source, bash]
----
$ ruby main.rb
$ git commit -m 'refactor: マジックナンバーの置き換え'
----

TODOリスト
- [x] 数を文字列にして返す
 - [x] 1を渡したら文字列"1"を返す
 - [x] 2を渡したら文字列"2"を返す
- [x] 3 の倍数のときは数の代わりに｢Fizz｣と返す
 - [x] 3を渡したら文字列"Fizz"を返す
- [x] 5 の倍数のときは｢Buzz｣と返す
 - [x] 5を渡したら文字列"Buzz"を返す
- [x] 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
 - [x] 15を渡したら文字列"FizzBuzz"を返す
- [x] 1 から 100 までの数を返す
  - [x] はじめは文字列1を返す
  - [x] 最後は文字列Buzzを返す
  - [x] 2番目は文字列Fizzを返す
  - [x] 4番目は文字列Buzzを返す
  - [x] 14番目は文字列FizzBuzzを返す
- [ ] プリントする

[source, ruby]
----
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz && is_buzz
    return 'Fizz' if is_fizz
    return 'Buzz' if is_buzz
    number.to_s
  end

  def self.generate_list
    (1..MAX_NUMBER).map { |i| generate(i) }
  end
end

puts FizzBuzz.generate_list
----

[source, bash]
----
$ ruby main.rb 
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
26
Fizz
28
29
FizzBuzz
31
32
Fizz
34
Buzz
Fizz
37
38
Fizz
Buzz
41
Fizz
43
44
FizzBuzz
46
47
Fizz
49
Buzz
Fizz
52
53
Fizz
Buzz
56
Fizz
58
59
FizzBuzz
61
62
Fizz
64
Buzz
Fizz
67
68
Fizz
Buzz
71
Fizz
73
74
FizzBuzz
76
77
Fizz
79
Buzz
Fizz
82
83
Fizz
Buzz
86
Fizz
88
89
FizzBuzz
91
92
Fizz
94
Buzz
Fizz
97
98
Fizz
Buzz
Started with run options --seed 48518

  19/19: [====================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00834s
19 tests, 21 assertions, 0 failures, 0 errors, 0 skips
----

[source, bash]
----
$ git commit -m 'feat: FizzBuzz'
----

TODOリスト

- [x] 数を文字列にして返す
 - [x] 1を渡したら文字列"1"を返す
 - [x] 2を渡したら文字列"2"を返す
- [x] 3 の倍数のときは数の代わりに｢Fizz｣と返す
 - [x] 3を渡したら文字列"Fizz"を返す
- [x] 5 の倍数のときは｢Buzz｣と返す
 - [x] 5を渡したら文字列"Buzz"を返す
- [x] 3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す
 - [x] 15を渡したら文字列"FizzBuzz"を返す
- [x] 1 から 100 までの数を返す
  - [x] はじめは文字列1を返す
  - [x] 最後は文字列Buzzを返す
  - [x] 2番目は文字列Fizzを返す
  - [x] 4番目は文字列Buzzを返す
  - [x] 14番目は文字列FizzBuzzを返す
- [x] プリントする

== エピソード2
=== 継続的インテグレーションから始まるテスト駆動開発

=== オブジェクト指向から始まるテスト駆動開発
==== TODOリスト作成
==== タイプ1の場合
==== タイプ2の場合
==== タイプ3の場合
==== フィールドのカプセル化
==== ポリモーフィズムによる条件記述の置き換え
==== スーパークラスの抽出
==== オブジェクトによるプリミティブの置き換え
==== アサーションの導入
==== 例外によるエラーコードの置き換え
==== モジュールの分割

== エピソード3
=== クライアント開発から始まるテスト駆動開発
==== APIサービスを作る
==== APIサービスと連携する
==== UIを作る
==== UIとAPIサービスを連携する

== エピソード4
=== 本番運用から始まるテスト駆動開発
==== E2Eテストのセットアップ
==== クライアントモジュールの分割
==== 本番環境と開発環境で表示を切り返る
==== コードレビュー

== 参照

=== 参考サイト

- https://channel9.msdn.com/Events/de-code/2017/DO03?ocid=player[50 分でわかるテスト駆動開発^]
- https://backlog.com/ja/git-tutorial/[サルでもわかるGit入門〜バージョン管理を使いこなそう〜^]
- https://t-wada.hatenablog.jp/entry/clean-code-that-works[動作するきれいなコード: SeleniumConf Tokyo 2019 基調講演文字起こし+α]

=== 参考図書

++++
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=k2works0c-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=4274217884&linkId=568f25b974af5645e862928a12c354e1&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"></iframe>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=k2works0c-22&language=ja_JP&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=4774193976&linkId=fee0d915272172c2e25393dd52537bdc"></iframe>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=k2works0c-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=427405019X&linkId=08e705a5969e20f5129b4d3cefbcdb15&bc1=000000&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"></iframe>
++++

[bibliography]
== References

- テスト駆動開発[[tdd]] Kent Beck (著), 和田 卓人 (翻訳):
  オーム社; 新訳版 (2017/10/14)
- プロを目指す人のためのRuby入門 言語仕様からテスト駆動開発・デバッグ技法まで (Software Design plusシリーズ)[[pruby]] 伊藤 淳一  (著):
  技術評論社 (2017/11/25)